## [剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是 O(n)，空间复杂度是 O(1)。

**示例 1：**

**输入：**nums = [4,1,4,6]  
**输出：**[1,6] 或 [6,1]

**示例 2：**

**输入：**nums = [1,2,10,4,1,4,3,3]  
**输出：**[2,10] 或 [10,2]

**限制：** `2 <= nums.length <= 10000`

## 解题思路

这题有时间复杂度和空间复杂度限制，不能直接使用哈希表等。考虑如果只有一个数是一个，其他都是两个的话，可以将所有的数字都进行异或，最终得到的就是那一个单独的数字。而这题是有两个数只出现一次，如果有办法能进行分组，假设这两个为 a 和 b，如果能分组使得 a 和其他一些出现两次的一组，b 和剩下出现两次的一组，每组分别异或就可以分别得到 a 和 b 的值。

考虑 a ^ b = x，如果 x 的某一位为 0 的话，对于 a,b 中这个位是相同的（要不都为 0，要不都为 1），如果 x 的某一位为 1 的话，对于 a,b 中这个位是不同的（0 和 1 异或得到 1）；

尤其考虑将所有的数先异或得到 x，然后从 x 中找到一个二进制位是 1 的，来进行分组。因为 a 和 b 在这位上是不同的，是可以区分开来的，对于其他的数字相同的肯定是可以分在一组的；

```cpp
class Solution {
public:
    vector<int> singleNumbers(vector<int>& nums) {
        int res = 0;
        // 所有元素进行异或
        for (int num : nums) {
            res ^= num;
        }
        // 找到res中二进制是1的位
        int div = 1;
        while ((div & res) == 0) {
            div <<= 1;
        }
        // 根据div进行分组
        int a = 0, b = 0;
        for (int num : nums) {
            if (div & num) {
                a ^= num;
            } else {
                b ^= num;
            }
        }
        return {a, b};
    }
};
```

上面的 div 可以按照树状数组思路直接求得：

```cpp
int div = res & -res; // 取出最后一个位是1的
```