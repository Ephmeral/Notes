## 1 Query Plan

DBMS 将 SQL 语句转换为查询计划。查询计划中的操作符按照树状进行排列。数据从叶子节点流向根节点。树中根节点的输出就是查询结果。操作符通常是二进制的（1-2 个子节点）。同一查询计划可以通过多种方式执行。

## 2 Processing Models

DBMS 处理模型（processing models）定义了系统如何执行查询计划。它规定了查询计划的评估方向以及操作符之间沿途传递的数据类型。处理模型有不同的模式，针对不同的工作负载有不同的权衡。

这些模型可以实现 top-to-bottom 或 bottom-to-top 调用操作符。虽然 top-to-bottom 的方法更为常见，但 bottom-to-top 的方法可以更严格地控制流水线中的缓存/寄存器。

我们考虑的三种执行模式是
- Iterator Model：迭代器模型
- Materialization Model：物化模型
- Vectorized / Batch Model：矢量化/批处理模型
### Iterator Model

迭代器模型也称为火山（Volcano）模型或管道（Pipeline）模型，是最常见的处理模型，几乎所有（基于行的）DBMS 都使用这种模型。

迭代器模型的工作原理是为数据库中的每个操作符实现一个 Next 函数。
- 查询计划中的每个节点都会对其子节点调用 Next，直到到达叶节点，叶节点开始向其父节点发送元组进行处理。
- 然后，在检索下一个元组之前，每个元组都会在计划中尽可能向上处理。
- 这在基于磁盘的系统中非常有用，因为它允许我们在访问下一个元组或页面之前，充分利用内存中的每个元组。

迭代器模型示例图如图 1 所示。

![](pics/Pasted%20image%2020231011145743.png)
>图 1：迭代器模型示例——每个运算符的不同 Next 函数的伪代码。Next 函数本质上是对子运算符输出进行遍历的 for 循环。例如，根节点对其子节点（join 运算符）调用 Next，这是一种访问方法，它对关系 R 进行循环，并向上输出一个元组，然后对其进行操作。在处理完所有元组后，会发送一个空指针（或其他指示符），让父节点知道可以继续处理。

迭代器模型中的查询计划运算符具有很高的可组合性，而且易于推理，因为每个运算符都可以独立于查询计划树中的父运算符或子运算符来实现，只要它实现了如下的 Next 函数即可：
- 每次调用 Next 时，运算符要么返回一个元组，要么返回一个空标记（如果没有更多元组可发出）。
- 运算符实现了一个循环，在其子节点上调用 Next 以获取它们的元组，然后进行处理。这样，在父节点上调用 Next 会在子节点上调用 Next。作为回应，子节点将返回父节点必须处理的下一个元组。

迭代器模型允许 DBMS 在检索下一个元组之前，通过尽可能多的运算符对元组进行流水线处理。查询计划中针对给定元组执行的一系列任务称为流水线（pipeline）。

有些操作符会阻塞，直到子操作符发出所有元组。这类操作符的例子包括连接、子查询和排序（ORDER BY）。这类操作符被称为管道断路器（pipeline breakers）。

使用这种方法（LIMIT）可以轻松实现输出控制，因为操作符一旦获得所需的全部元组，就可以停止在其子操作符（或子操作符）上调用 Next。

### Materialization Model

物化模型（materialization model）是迭代器模型的一种特殊化，其中每个操作符一次性处理其输入，然后一次性输出结果。每个操作符每次都会返回其所有的 tuple，而不是使用一个返回单个 tuple 的 Next 函数。为了避免扫描过多的 tuples，数据库管理系统可以向下传播关于需要多少 tuples 的信息给后续操作符（如 LIMIT）。操作符将其输出 " 物化 " 为一个结果。输出可以是整个元组（NSM），也可以是列的子集（DSM）。物化模型图如图 2 所示。

![](pics/Pasted%20image%2020231011150221.png)

每个查询计划操作符都实现了一个输出函数：
- 操作符会一次性处理来自其子节点的所有 tuple。
- 该函数的返回结果就是该操作符将发出的所有数据 tuple。操作符执行完毕后，DBMS 将不再需要返回它来获取更多数据。

这种方法更适合 OLTP 工作负载，因为查询通常一次只访问少量 tuple。因此，检索元祖的函数调用较少。物化模型不适合具有大量中间结果的 OLAP 查询，因为 DBMS 可能需要在操作符之间将这些结果溢出到磁盘。

### Vectorization Model

与迭代器模型一样，矢量化模型（vectorization model ）中的每个操作符都实现了一个 Next 函数。不过，每个操作符发出的是一批数据（即向量），而不是单个元组。运算符的内部循环实现经过了优化，可以处理成批的数据，而不是一次处理单个项目。批次的大小可根据硬件或查询属性而变化。矢量化模型示例见图 3。

![](pics/Pasted%20image%2020231011150502.png)

矢量化模型方法非常适合需要扫描大量 tuple 的 OLAP 查询，因为调用 Next 函数的次数较少。

矢量化模型允许操作符更轻松地使用矢量化（SIMD）指令来处理成批的数据元组。

处理方向：
- 方法 1：从上到下（Top-to-Bottom）
	- 从根节点开始，将数据从子节点 " 拉 " 到父节点
	- 始终通过函数调用传递元组
- 方法 2：从下到上（Bottom-to-Top）
	- 从叶节点开始，将数据从子节点 " 推 " 到父节点
	- 允许在操作流水线中对缓存/寄存器进行更严格的控制

## 3 Access Methods

访问方法（access method）是指 DBMS 如何访问表中存储的数据。一般来说，访问模型有两种方法：要么从表中读取数据，要么通过顺序扫描从索引中读取数据。
### Sequential Scan

顺序扫描（sequential scan）操作符遍历表中的每一页，并从缓冲池中检索。当扫描遍历每一页上的所有元组时，它会评估谓词，以决定是否将元组发送给 next 运算符。

DBMS 维护一个内部游标，跟踪最后检查的页面/槽。

顺序表扫描几乎总是 DBMS 执行查询效率最低的方法。有许多优化方法可以帮助提高顺序扫描的速度：

- 预取（Prefetching）：提前取下几个页面，这样 DBMS 在访问每个页面时就不必阻塞存储 I/O。
- 缓冲池旁路（Buffer Pool Bypass）： 扫描操作符将从磁盘获取的页面存储在本地内存中，而不是缓冲池中，以避免 sequential flooding。
- 并行化（Parallelization）：使用多个线程/进程并行执行扫描。
- 延迟具体化（Late Materialization）：DSM DBMS 可以将 tuple 拼接延迟到查询计划的上半部分。这允许每个操作符向下一个操作符传递所需的最小信息量（如记录 ID、记录在列中的偏移量）。这只在列存储系统中有用。
- 堆集群（Heap Clustering）： 使用聚类索引指定的顺序将 tuple 存储在堆页面中。
- 近似查询（有损数据跳转）Approximate Queries (Lossy Data Skipping)： 在整个表的抽样子集上执行查询，以产生近似结果。这通常用于在允许低误差的情况下计算聚合，从而得出近似准确的答案。
- 区域地图（无损数据跳转）Zone Map (Lossless Data Skipping)： 预先计算页面中每个元组属性的聚合。然后，DBMS 可以通过先检查页面的 Zone Map 来决定是否需要访问该页面。每个页面的 Zone Map 都存储在不同的页面中，每个 Zone Map 页面通常有多个条目。因此，可以减少顺序扫描中检查的页面总数。在云数据库系统中，通过网络传输数据会产生较大的成本，因此 Zone Map 就显得尤为重要。Zone Map 示例见图 4。

![](pics/Pasted%20image%2020231011151510.png)

顺序扫描模型的局限性包括函数开销和缺乏并行化（例如无法利用矢量运算）。
### Index Scan

在索引扫描（Index Scan）中，DBMS 选择一个索引来查找查询所需的元组。

假设现在有一个查询语句：`select * from students where age < 30 and dept = 'CS' and country = 'US';`

场景 1：有 99 个人年龄小于 30，但是只有 2 个人是 CS 学院的 。  
场景 2：有 99 个人是 CS 学院的，但是只有 2 个人年龄小于 30。

考虑一个包含 100 个元组和两个索引的表：年龄和学院。
- 场景 1 下，最好在扫描中使用学院索引，因为它只有两个元组要匹配。 选择年龄索引并不比简单的顺序扫描好多少。
- 场景 2，年龄索引会消除更多不必要的扫描，是最佳选择。

DBMS 的索引选择过程涉及许多因素（Lecture14 会介绍），包括：  
• 索引包含哪些属性  
• 查询引用哪些属性  
• 属性的值域  
• 谓词组合  
• 索引是否具有唯一或非唯一键

更高级的 DBMS 支持多索引扫描。 当对查询使用多个索引时，DBMS 使用每个匹配索引计算记录 ID 集，根据查询的谓词组合这些集，并检索记录并应用可能保留的任何谓词。 DBMS 可以使用位图、哈希表或布隆过滤器通过集合交集来计算记录 ID。 请参阅图 6 了解使用多索引扫描的示例。

![](pics/Pasted%20image%2020231011170427.png)

## 4 Modification Queries

修改数据库的操作符（INSERT、UPDATE、DELETE）需要检查以及更新索引。 对于 UPDATE/DELETE，子操作符传递目标元组的记录 ID，并且必须跟踪以前看到的元组。

关于如何处理 INSERT 运算符，有两种实现选择：  
• 选择#1：在运算符内部物化元组。  
• 选择#2：操作符插入从子操作符传入的任何元组。

### Halloween Problem

万圣节问题（Halloween Problem）是一种异常现象，更新操作会改变元组的物理位置，导致扫描操作员多次访问该元组。这种情况可能发生在集群表或索引扫描中。

这种现象最初是由 IBM 研究人员在 1976 年万圣节当天构建 System R 时发现的。解决这个问题的方法是跟踪每次查询的修改记录 ID。

## 5 Expression Evaluation

DBMS 将 WHERE 子句表示为表达式树（见图 7）。树中的节点代表不同的表达式类型。

![](pics/Pasted%20image%2020231011170920.png)

可存储在树节点中的表达式类型示例：
- 比较（=、<、>、!=）
- 连接（AND）
- 析取（OR）
- 算术运算符（+、-、\*、/、%）
- 常量和参数值
- 元组属性引用

要在运行时评估表达式树，数据库管理系统会维护一个上下文句柄，其中包含执行的元数据，如当前元组、参数和表模式。然后，DBMS 走查表达式树，评估其运算符并生成结果。

以这种方式评估谓词的速度很慢，因为 DBMS 必须遍历整个树，并确定对每个操作符采取的正确操作。更好的方法是直接评估表达式（想想 JIT 编译）。DBMS 将根据内部成本模型决定是否采用代码生成来加速查询。

