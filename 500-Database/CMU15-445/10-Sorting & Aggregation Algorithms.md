## 1 Sorting

DBMS 需要对数据进行排序，因为在关系模型下，表中的元组没有特定的顺序。排序在 ORDER BY、GROUP BY、JOIN 和 DISTINCT 操作中（可能）被使用。
- 如果需要排序的数据可以存放在内存中，则可以使用标准的排序算法（例如快速排序）。
- 如果数据在内存中放不下，则 DBMS 需要使用外部排序，它能够根据需要将数据溢出到磁盘中，并更倾向于顺序而不是随机的 I/O。

如果查询包含带有 LIMIT 的 ORDER BY 子句，那么 DBMS 只需要扫描一次数据来找到前 N 个元素。这被称为 **Top-N** 堆排序。对于堆排序来说，理想情况是前 N 个元素可以在内存中容纳，这样 DBMS 只需在扫描数据的时候，在内存中维护一个有序优先队列。

![](pics/Pasted%20image%2020230914162910.png)


对于无法完全容纳在内存中的大规模数据，标准的排序算法是外部归并排序（**external merge sort**）。这是一种分而治之的排序算法，它将数据集分成不同的运行集（runs），并对它们进行单独排序。它可以根据需要将运行集（runs）写到磁盘，然后逐个读取它们。该算法由两个阶段组成：

- 阶段 1 - 排序（Sorting）：首先，对内存中能够存放的小块数据进行排序，然后将排序后的页面写回磁盘中。
- 阶段 2 - 合并（Merge）：接下来，该算法将排序后的子文件组合成一个更大的文件。


运行集（run）是一个键值对列表：
- Key：用于计算排序顺序的属性。
- Value：两种选择
	- Tuple (early materialization).
	- Record ID (late materialization)

![](pics/Pasted%20image%2020230914163400.png)

### Two-way Merge Sort

该算法中最基本的版本是两路归并排序（Two-way Merge Sort）。
- 在排序阶段，算法会读取每一页，对其进行排序，然后将排序后的版本写回磁盘。
- 在合并阶段，它使用三个缓冲页面。它从磁盘中读取两个已排序的页面，将它们合并到第三个缓冲页面中。每当第三页填满时，它会被写回磁盘并替换为空白页。
- 每组已排序的页面称为一个运行集（run）。然后，算法递归地将这些运行集合并在一起。

![](pics/Pasted%20image%2020230914164424.png)

下面是一个具体的例子：

![](pics/Pasted%20image%2020230914164442.png)

如果 N 是数据页面的总数，该算法对数据进行了 $1 + ⌈log_2N⌉$ 次 passes（1 次用于第一次排序步骤，然后 $⌈log2N⌉$ 次用于递归合并）。总 I/O 成本是 2N ×（# of passes），因为每次通行都对每一页执行一次 I/O 读取和一次 I/O 写入。

注意：  
- 该算法只需要三个缓冲池页面来执行排序（B=3）。两个输入页面，一个输出页面。
- 即使有更多的缓冲空间可用（B>3），如果工作进程必须阻塞在磁盘 I/O 上，也无法有效地利用它们。

### General (K-way) Merge Sort

通用版本的算法允许 DBMS 利用多于三个缓冲页面，假设 B 是可用的总缓冲页面数。
- 在排序阶段，算法可以一次读取 B 个页面，并将 $⌈N / B⌉$ 个已排序运行集写回磁盘中。
- 合并阶段也可以在每次 pass 中合并多达 B-1 个运行集，同样使用一个缓冲页面来存储合并后的数据，并根据需要写回磁盘。

复杂度分析：
- 该算法执行了 1 + $log_{B−1}⌈N / B⌉$ 次 pass（一次用于排序阶段，$log_{B−1}N/B$次用于合并阶段）。
- 总的 I/O 成本是 2N ∙ (# of passes)，因为在每次 pass 中都必须对每一页进行读取和写入。

例子：要确定在给定条件下（N=108 页，B=5 个缓冲池页面）进行排序需要多少 pass？

![](pics/Pasted%20image%2020230914165526.png)

### Double Buffering Optimization

一种外部归并排序的优化方法是在后台预取下一个运行集，并将其存储在第二个缓冲区中，同时系统正在处理当前运行集。这通过持续利用磁盘减少了每个步骤中 I/O 请求的等待时间。这种优化需要使用多个线程，因为预取应该在计算当前运行集的同时进行。

![](pics/Pasted%20image%2020230914165721.png)

### Using B+Trees

有时，DBMS 使用现有的 B+ 树索引来辅助排序，比使用外部归并排序算法更有优势。

如果索引是一个聚簇索引，DBMS 可以直接遍历 B+ 树。由于索引是聚簇的，数据将按正确的顺序存储，因此 I/O 访问将是连续的。这意味着它始终优于外部归并排序，因为不需要进行计算。

![](pics/Pasted%20image%2020230914165840.png)

如果索引是非聚簇的，遍历树几乎总是更差的选择，因为每个记录都可能存储在任何页面上，因此几乎所有记录访问都需要进行磁盘读取。

![](pics/Pasted%20image%2020230914165858.png)

## 2 Aggregations

查询计划中的聚合运算符（Aggregations）将一个或多个元组的值折叠为单个标量值。例如如平均值、最大值、最小值等。有两种实现聚合的方法：(1) 排序和 (2) 散列。

### Sorting

![](pics/Pasted%20image%2020230914170118.png)

DBMS 首先根据 GROUP BY 键对元组进行排序。如果所有数据都可以存放在缓冲池中，它可以使用内存中的排序算法（例如，快速排序），或者如果数据大小超过了内存，它可以使用外部归并排序算法。然后，DBMS 在排序后的数据上执行顺序扫描以计算聚合。操作符的输出将按键进行排序。

在执行排序聚合时，有序地排列查询操作以最大化效率非常重要。例如，如果查询需要进行筛选，最好先执行筛选，然后对筛选后的数据进行排序，以减少需要排序的数据量。这可以显著提高查询性能，因为只有通过筛选的数据才会进入排序阶段，从而减少了不必要的排序开销。

### Hashing

哈希计算聚合在成本上可能比排序更低。DBMS 在扫描表时填充一个临时哈希表。对于每个记录，检查哈希表中是否已经存在条目，并执行适当的修改。如果哈希表的大小太大而无法容纳在内存中，那么 DBMS 必须将其溢写到磁盘上。完成这一过程有两个阶段：

- 阶段 1 - Partition：使用哈希函数 h1 根据目标哈希键将元组分成基于磁盘的分区。这将使所有匹配的元组都放在同一个分区中。DBMS 通过输出缓冲区将分区溢写到磁盘。  
- 阶段 2 - ReHash：对于磁盘上的每个分区，将其页面读入内存，并基于第二个哈希函数 h2（其中 h1 ≠ h2）构建一个内存中的哈希表。然后遍历此哈希表的每个存储桶，将匹配的元组聚集在一起以进行聚合计算。这假设每个分区都适合在内存中。

![](pics/Pasted%20image%2020230914171648.png)  
![](pics/Pasted%20image%2020230914171702.png)

在重新哈希阶段，DBMS 可以将存储形式为（GroupByKey→RunningValue）的键值对来聚合计算。RunningValue 的内容取决于聚合函数。要将新元组插入哈希表中，可以按照以下步骤进行：
- 如果找到匹配的 GroupByKey，然后根据聚合函数的要求适当地更新 RunningValue。
- 否则，插入一个新的（GroupByKey→RunningValue）键值对。

![](pics/Pasted%20image%2020230914171721.png)