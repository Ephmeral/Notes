## 1 Introduction

DBMS 负责管理其内存，并在磁盘和内存之间高效地移动数据。由于在大部分情况下，无法直接在磁盘上对数据进行操作，因此任何数据库都必须能够将以文件形式表示的数据有效地从磁盘移入内存，以便进行使用。这种交互的示意图如图 1 所示。DBMS 面临的一个障碍是尽量减少数据移动所带来的减速问题。理想情况下，数据应该“看起来”就像已经全部在内存中一样。执行引擎不应该担心数据如何被获取到内存中。

![](pics/Pasted%20image%2020230831141404.png)

从另一个角度来看，可以将这个问题看作是关于空间和时间控制的问题。

- 空间控制（Spatial Control）涉及页面在磁盘上的物理写入位置。空间控制的目标是尽量让经常一起使用的页面在磁盘上物理位置上越靠近越好。
- 时间控制（Temporal Control）涉及何时将页面读入内存，以及何时将其写入磁盘。时间控制的目标是尽可能的减少从磁盘读取数据而产生的停顿次数。

## 2 Locks vs. Latches
  
在讨论 DBMS 如何保护其内部元素时，我们需要区分锁（Locks）和闩锁（Latches）的概念：
- 锁（Locks）：锁是一种更高层次的逻辑原语，用于保护数据库的内容（例如元组、表、数据库）免受其他事务的影响。事务将在其整个持续时间内持有锁。数据库系统可以在查询的时候向用户展示哪些锁正在被持有。锁需要能够回滚更改。
- 闩锁（Latches）：闩锁是 DBMS 在其内部数据结构中的关键部分（例如哈希表、内存区域）使用的低层保护原语。闩锁仅在进行操作的时候持有。闩锁不需要能够回滚更改。

## 3 Buffer Pool

缓冲池（Buffer Pool）是从磁盘读取的页面的内存缓存。它本质上是在数据库内部分配的一个大内存区域，用于存储从磁盘中获取的页面。

缓冲池的内存区域被组织成一组固定大小的页面数组，每个数组条目称为一个帧（Frame）。每次 DBMS 请求一个 page 时，page 会拷贝到缓冲池的一个帧中。
- 当 DBMS 请求页面时，首先可以在缓冲池中进行搜索，如果缓冲池中没有找到该页面，则从磁盘中获取页面的副本；
- 当缓冲池满的时候，需要从缓冲池中选取一个页面进行替换；

![](pics/Pasted%20image%2020230831142401.png)

脏页面（dirty page）：指的是那些在内存中的页面被修改了，但是磁盘中对应的页面还没有修改。脏页面会被缓存在缓冲池中，不会立即写回。

### Buffer Pool Meta-data

为了高效且正确地使用缓冲池，缓冲池必须维护一些元数据。

首先，page table 是一个内存中的哈希表，用于跟踪当前在内存中的页面。它将页面标识映射到缓冲池中的帧位置。由于缓冲池中页面的顺序不一定反映磁盘上的顺序，这个额外的间接层可以用来确定页面在缓冲池中的位置。

page table 还针对每个页面维护了额外的元数据，包括脏标志（dirty flag）和引用计数器（pin/reference counter）。
- 脏标志（dirty-flag）：当任何线程修改页面的时候，脏标志会被设置为 true。这意味着这个页面必须被写回到磁盘。
- 引用计数器（pin/reference Counter）：跟踪当前正在访问该页面的线程数（无论是读取还是修改）。线程在访问页面之前必须递增计数器。如果页面的计数大于零，则存储管理器不允许从内存中驱逐（evict）该页面。（这里的驱逐指的是缓冲池满的时候，将这个页面替换出去）

**page table vs page directory**
- page directory 是从页面标识到数据库文件中页面位置的映射，所有更改都必须记录在磁盘上，以便在重新启动时允许 DBMS 找到这些更改；
- page table 是页面标识到缓冲池中帧的映射，这是内存中的数据结构，不需要存放在磁盘中；

### Memory Allocation Policies
  
数据库中的内存分配有两种策略。
- 全局策略（Global Policies）涉及 DBMS 应根据正在执行的整个工作负载作出的决策。它考虑所有活动事务，以找到一个最佳的内存分配决策。
- 局部策略（Local Policies），将帧分配给特定的事务，而不考虑并发事务的行为。

大多数系统使用全局和局部的组合策略。它会做出使单个查询或事务运行更快的决策，即使这对整个工作负载来说可能不是最优的。

## 4 Buffer Pool Optimizations

有多种方法可以优化缓冲池，以适应不同应用程序的工作负载。

### Multiple Buffer Pools

DBMS 可以为不同目的维护多个缓冲池（例如，每个数据库一个缓冲池，每个页面类型一个缓冲池）。然后，每个缓冲池可以采用适用于其内部存储的数据的局部策略。这种方法有助于减少闩锁 (latch) 争用，提高局部性。

有两种方法将所需页面映射到对应的缓冲池：
- 对象标识（Object IDs）：可以在记录标识（record ids）中嵌入对象标识符，然后维护从对象到特定缓冲池的映射。
- 哈希（hashing）：对页面标识进行哈希，以选择访问哪个缓冲池。

![](pics/Pasted%20image%2020230831151142.png)  
![](pics/Pasted%20image%2020230831151155.png)

### Pre-fetching

DBMS 还可以通过基于查询计划进行预取页面（prefetch pages）来进行优化。在处理第一组页面时，第二组页面可以被预取到缓冲池中。当顺序访问许多页面时，这种方法通常被 DBMS 广泛使用。

例如在使用下面 SQL 语句进行范围查询的时候：

```sql
SELECT * FROM A
WHERE val BETWEEN 100 AND 250
```

当索引访问到 index-page1，可以提前把 index-page3 和 index-page5 放入到缓冲池中：

![](pics/Pasted%20image%2020230831151701.png)

### Scan Sharing (Synchronized Scans)

查询可以重用从存储或操作计算中检索的数据。如果一个查询 A 已经扫描过一部分数据，另外一个查询 B 发现有一部分和 A 是相同的，那么 B 就可以将自己的游标（cursor）移动到 A 上，这样等 A 扫描完之后，B 可以继续扫描剩下的数据。这也被称为同步扫描（synchronized scans）。

下面是一个例子：

查询 Q1 `SELECT SUM(val) FROM A` 假设从磁盘 page0 到 page5 都需要扫描一遍

查询 Q1 先扫描 page0，然后依次扫描到 page2：

![](pics/Pasted%20image%2020230831152910.png)  
![](pics/Pasted%20image%2020230831152929.png)

继续扫描 page3 的时候，发现缓冲池满了，此时考虑将 page0 替换出去：

![](pics/Pasted%20image%2020230831153137.png)

这个时候如果另外一个线程执行查询 Q2 `SELECT AVG(val) FROM A` 发现已经 Q1 和 Q2 有部分数据是相同的，这个时候将查询 Q2 游标移动到和 Q1 相同的位置：

![](pics/Pasted%20image%2020230831153318.png)

这个时候 Q1 会继续扫描 page3-5，同时 Q2 也一起扫描了这些页面

![](pics/Pasted%20image%2020230831153410.png)

当 Q1 扫描完成的时候，Q2 会重新从 page0 扫描到 page2：

![](pics/Pasted%20image%2020230831153453.png)  
![](pics/Pasted%20image%2020230831153505.png)

### Buffer Pool Bypass

当有大量数据的线性扫描的话，如果将需要的页面都读入到缓冲池当中，这会导致缓冲池的污染，因为线性扫描的数据通常只需要使用一次。DBMS 会做优化，出现这种查询的时候，单独分配一块内存。Buffer Pool Bypass 也可以用在临时数据上，例如排序和连接。

## 5 OS Page Cache

大多数磁盘操作都通过操作系统的 API 进行。除非明确指定，否则操作系统会维护自己的文件系统缓存。 大多数 DBMS 使用直接 I/O (**O_DIRECT**) 来绕过操作系统的缓存，以避免页面的冗余复制和管理不同的页面替换策略。 Postgres 是一个使用操作系统的页面缓存的数据库系统的例子。

![](pics/Pasted%20image%2020230831154529.png)

## 6 Buffer Replacement Policies

当 DBMS 需要释放一个帧以为新页面腾出空间时，它必须决定从缓冲池中驱逐哪个页面。替换策略是 DBMS 实现的一种算法，用于在需要空间时决定从缓冲池中驱逐哪些页面。替换策略的实现目标包括提高正确性、准确性、速度和元数据开销。

### Least Recently Used (LRU)

最近最少使用（Least Recently Used，LRU）替换策略维护了每个页面上次访问的时间戳。DBMS 选择驱逐时间戳最早的页面。这个时间戳可以存储在一个单独的数据结构中，比如队列，以便进行排序，并通过减少驱逐时的排序时间来提高效率。

### CLOCK

时钟（CLOCK）策略是对 LRU 的一种近似，而无需为每个页面单独维护时间戳。在时钟策略中，每个页面都被赋予一个引用位（reference bit）。当访问一个页面时，引用位被设置为 1。
  
为了可视化这个过程，可以将页面组织成一个环形缓冲区，并使用一个“时钟指针”。在进行清除操作时，检查页面的引用位是否被设置为 1。如果是，则将其设置为零；如果不是，则将其驱逐。通过这种方式，时钟指针在驱逐之间记住了位置。

![](pics/Pasted%20image%2020230831154924.png)

### Alternatives

LRU 和 CLOCK 页面替换策略有很多问题。具体而言，LRU 和 CLOCK 容易受到顺序洪泛（sequential flooding）的影响，其中缓冲池的内容由于顺序扫描而受损。因为顺序扫描会读取每一页，所读页面的时间戳并不能反映实际上需要的页面。换句话说，最近使用过的页面实际上是最不需要的页面。

有三种解决方案来应对 LRU 和 CLOCK 策略的缺点：
- LRU-K，它跟踪最近 K 次引用的历史记录作为时间戳，并计算连续访问之间的间隔。这个历史记录用于预测页面下次被访问的时间。
- 基于查询的本地化（localization）。DBMS 根据每个事务/查询选择要驱逐的页面。这最大程度地减少了每个查询对缓冲池的污染。
- 优先级提示（priority hints）：DBMS 知道查询过程中每个页面的上下文，它可以用来提示缓冲池这个页面是否重要。

### Dirty Pages

带有脏位（dirty bits）的页面有两种处理方法。
- Fast Path：丢弃缓冲池中未被标记为脏的任何页面；
- Slow Path：是将脏页面写回磁盘，以确保页面的更改可以被持久化；

这两种方法说明了快速驱逐与写入脏页面之间的权衡，后者在未来不会被再次读取。

避免不必要地写出页面的一种方法是后台写入（background writing）。通过后台写入，DBMS 可以定期遍历 page table 并将脏页面写入磁盘中。当脏页面被安全地写入后，DBMS 可以驱逐页面或者只是取消脏标志。

## 7 Other Memory Pools

DBMS 除了需要内存来存储元组和索引之外，还需要内存来处理其他事务。这些其他内存池可能根据实现方式并不总是由磁盘支持。  
- Sorting + Join Buffers  
- Query Caches  
- Maintenance Buffers  
- Log Buffers  
- Dictionary Caches