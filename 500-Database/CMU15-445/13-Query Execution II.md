## 1 Background

以前讨论查询执行时，假定查询是由单个 Worker（即线程）执行的。 然而，在实际操作中，查询通常是由多个 Worker 并行执行的。

并行执行为 DBMS 带来了许多关键优势：
- 提高吞吐量（每秒查询次数更多）和延迟（每次查询时间更短）性能。
- 从 DBMS 外部客户的角度看，响应速度和可用性得到提高。
- 可能降低总拥有成本（TCO）。该成本包括硬件采购和软件许可，以及部署 DBMS 的人力开销和机器运行所需的能源。

DBMS 支持两种类型的并行：查询间并行（inter-query parallelism）和查询内并行（intra-query parallelism）。

## 2 Parallel vs Distributed Databases

在并行和分布式系统中，数据库被分散到多个 " 资源 " 中，以提高并行性。这些资源可以是计算资源（如 CPU 内核、CPU sockets、GPU、附加机器）或存储资源（如磁盘、内存）。

必须区分并行系统和分布式系统：
- 并行 DBMS：在并行 DBMS 中，资源或节点在物理上彼此靠近。这些节点通过高速互连进行通信。假设资源之间的通信不仅快速，而且便宜可靠。
- 分布式 DBMS：在分布式 DBMS 中，资源之间可能相距甚远；这可能意味着数据库跨越世界不同地区的机架或数据中心。因此，资源使用较慢的互连（通常通过公共网络）进行通信。节点之间的通信成本较高，而且故障不容忽视。

即使数据库在物理上被划分为多个资源，但在应用程序看来，它仍然是一个单一的逻辑数据库实例。因此，在单节点 DBMS 上执行的 SQL 查询在并行或分布式 DBMS 上应产生相同的结果。

## 3 Process Models

DBMS 处理模型（process model）定义了系统如何支持来自多用户应用程序/环境的并发请求。DBMS 由一个或多个工作者（workers）组成，他们负责代表客户执行任务并返回结果。应用程序可能会同时发送一个大型请求或多个请求，这些请求必须在不同的工作者之间进行分配。

DBMS 可采用两种主要的进程模式：一个进程一个 worker 和一个线程一个 worker。第三种常见的数据库使用模式采用嵌入式方法。

### Process per Worker

最基本的方法是 process per worker。在这里，每个工作进程都是一个独立的操作系统进程，因此依赖于操作系统调度程序。应用程序发送请求，并建立与数据库系统的连接。某个调度程序接收到请求后，会选择其中一个工作进程来管理连接。然后，应用程序与负责执行查询请求的工作进程直接通信。这一系列事件如图 1 所示。

![](pics/Pasted%20image%2020231011174119.png)

依赖操作系统进行调度有效地减少了 DBMS 对执行的控制。但是，这种模式依赖于共享内存来维护全局数据结构，或者依赖于消息传递，而消息传递的开销更大。

Process per Worker 模式的优势在于，进程崩溃不会破坏整个系统，因为每个 Worker 都在自己的操作系统进程中运行。

这种进程模式会带来一个问题，即不同进程中的多个 Worker 会对同一页面进行多次复制。最大化内存使用率的解决方案是为全局数据结构使用共享内存，这样不同进程中运行的 Worker 就可以共享这些数据结构。

IBM DB2、Postgres 和 Oracle 等系统都采用了这种模式。开发这些 DBMS 时，pthreads 尚未成为标准的线程模型。不同操作系统的线程语义各不相同，而 fork() 的定义则更为明确。

### Thread per Worker

目前最常见的模式是 Thread per Worker。每个数据库系统只有一个带有多个工作线程的进程，而不是由不同的进程执行不同的任务。在这种环境下，DBMS 可以完全控制任务和线程，管理自己的调度。多线程模型可以使用或不使用调度线程。Thread per Worker 模型的示意图如图 2 所示。

![](pics/Pasted%20image%2020231011174416.png)

使用多线程架构具有一定的优势。首先，每次上下文切换的开销较少。此外，无需维护共享模型。但是，线程崩溃有可能导致整个数据库进程瘫痪。此外，Thread per Worker 模型并不一定意味着 DBMS 支持查询内部并行性。

过去 20 年中创建的几乎所有 DBMS 都采用了这种方法，包括 Microsoft SQL Server 和 MySQL。IBM DB2 和 Oracle 也更新了它们的模型，以提供对这种方法的支持。Postgres 和 Postgres 衍生数据库在很大程度上仍使用基于进程的方法。

### Scheduling

总之，对于每个查询计划，数据库管理系统都必须决定在何处、何时以及如何执行。相关问题包括：
- 应该使用多少个任务？
- 应该使用多少个 CPU 内核？
- 任务应在哪些 CPU 内核上执行？
- 任务应在何处存储其输出？

在决定查询计划时，DBMS 总是比操作系统知道得更多，因此应优先考虑操作系统。

### Embedded DBMS

数据库的一种非常不同的使用模式涉及在应用程序的同一地址空间中运行系统，这与数据库独立于应用程序的客户端 - 服务器模型相反。 在这种情况下，应用程序将设置要在数据库系统上运行的线程和任务。 应用程序本身将主要负责调度。 图 3 显示了嵌入式 DBMS 的调度行为图。

DuckDB、SQLite 和 RocksDB 是最著名的嵌入式 DBMS。

![](pics/Pasted%20image%2020231011174639.png)

## 4 Inter-Query Parallelism

在查询间并行中，DBMS 同时执行不同的查询。 由于多个 workers 同时运行请求，因此整体性能得到了提高。 这增加了吞吐量并减少了延迟。

如果查询是只读的，则查询之间几乎不需要协调。 但是，如果多个查询同时更新数据库，则会出现更复杂的冲突。 这些问题将在第 15 讲中进一步讨论。

## 5 Intra-Query parallelism

在查询内并行中，DBMS 并行执行单个查询的操作。 这减少了长时间运行的查询的延迟。查询内并行性的组织可以根据生产者/消费者范例来考虑。

每个操作符都是数据的生产者，也是其下运行的某个操作符的数据的消费者。每个关系运算符都存在并行算法。 DBMS 可以让多个线程访问集中式数据结构，也可以使用分区来划分工作。  

在查询内并行中，存在三种类型的并行：运算符内并行、运算符间并行和密集并行。 这些方法并不相互排斥。 DBMS 的责任是将这些技术结合起来，以优化给定工作负载的性能。

### Intra-Operator Parallelism (Horizontal)

在运算符内并行性（intra-operator parallelism）中，查询计划的运算符被分解为独立的片段，这些片段对不同（不相交）的数据子集执行相同的功能。

DBMS 将交换（exchange）运算符插入到查询计划中以合并子运算符的结果。 交换运算符阻止 DBMS 执行计划中位于其上方的运算符，直到它收到来自子级的所有数据。 图 4 显示了一个示例。

![](pics/Pasted%20image%2020231011175315.png)
>此 SELECT 的查询计划是对 A 进行顺序扫描，并将其输入到筛选运算符中。 为了并行运行它，查询计划被划分为不相交的片段。 给定的计划片段由不同的 worker 操作。 交换操作符在所有片段上同时调用 Next，然后从各自的页面检索数据。

一般来说，exchange 分为三类：  
- 收集 (Gather)：将多个 worker 的结果合并到一个输出流中。这是并行 DBMS 中最常用的类型。  
- 分发 (Distribute)：将单个输入流拆分为多个输出流。  
- 重新分区 (Repartition)：跨多个输出流重新组织多个输入流。这允许 DBMS 获取以一种方式分区的输入，然后以另一种方式重新分配它们。

![](pics/Pasted%20image%2020231011181454.png)

### Inter-Operator Parallelism (Vertical)

在运算符间并行性（Inter-Operator Parallelism）中，DBMS 重叠运算符，以便将数据从一个阶段输送到下一阶段，而无需具体化。 这有时称为流水线并行性。 请参见图 5 中的示例。这种方法广泛用于流处理系统，流处理系统是对输入元组流持续执行查询的系统。

![](pics/Pasted%20image%2020231011175816.png)

### Bushy Parallelism

Bushy 并行性是运算符内并行性和运算符间并行性的混合体，其中工作线程同时执行来自查询计划的不同部分的多个运算符。

DBMS 仍然使用交换运算符来组合这些段的中间结果。 图 6 显示了一个示例。

![](pics/Pasted%20image%2020231011175913.png)

## 6 I/O Parallelism

如果磁盘始终是主要瓶颈，那么使用额外的进程/线程并行执行查询不会提高性能。 因此，能够将数据库拆分到多个存储设备上非常重要。

为了解决这个问题，DBMS 使用 I/O 并行性将数据分散到多个设备上。I/O 并行的两种方法是：多磁盘并行（Multi-Disk Parallelism）和数据库分区（Database Partitioning）。

### Multi-Disk Parallelism

在多磁盘并行中，操作系统/硬件配置为跨多个存储设备存储 DBMS 的文件。 这可以通过存储设备或 RAID 配置来完成。所有存储设置对 DBMS 都是透明的，因此 worker 无法在不同的设备上操作，因为 DBMS 不知道底层的并行性。

### Database Partitioning

在数据库分区中，数据库被分成不相交的子集，这些子集可以分配给离散的磁盘。 某些 DBMS 允许指定每个单独数据库的磁盘位置。 如果 DBMS 将每个数据库存储在单独的目录中，则在文件系统级别很容易做到这一点。 所做更改的日志文件通常是共享的。

逻辑分区（logical partitioning）的思想是将单个逻辑表分割成不相交的物理段，并单独存储/管理。 理想情况下，这种分区对于应用程序来说是透明的。 也就是说，应用程序应该能够访问逻辑表，而无需关心事物的存储方式。  

我们将在本学期晚些时候讨论分布式数据库时介绍这些方法。