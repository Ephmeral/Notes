## 1 Overview

由于 SQL 是声明性的，查询只告诉数据库管理系统 (DBMS) 要计算什么，而不告诉它如何计算。因此，DBMS 需要将 SQL 语句转换成可执行的查询计划（query plan）。但是，在查询计划中执行每个操作符（例如，连接算法）有不同的方式，这些计划之间的性能差异会存在。DBMS 的优化器（optimizer）的工作是为任何给定的查询选择一个最优的计划。

第一个查询优化器的实现是 IBM System R，它设计于 1970 年代。在这之前，人们不相信数据库管理系统 (DBMS) 能够构建比人类更好的查询计划。许多 System R 优化器的概念和设计决策至今仍在使用。

有两种策略用于查询优化：
- 第一种方法是使用静态规则或启发式（heuristics）方法。启发式方法将查询的部分与已知模式匹配，以组装查询计划。这些规则会改变查询计划以提高查询效率。尽管这些规则可能需要查看目录以了解数据的结构，但它们不需要直接检查数据本身。
- 另一种替代方法是使用基于成本的搜索（cost-based search）来读取数据并估算执行等效计划的成本。成本模型选择最低成本的计划。

查询优化是构建 DBMS 中最困难的部分。一些系统尝试应用机器学习来提高优化器的准确性和效率，但目前没有主要的 DBMS 采用基于这一技术的优化器。

### Logical vs. Physical Plans

优化器生成一个逻辑代数表达式到最佳等效物理代数表达式的映射。逻辑计划大致等同于查询中的关系代数表达式。

物理运算符定义了在查询计划中的不同操作符使用访问路径的具体执行策略。
- 物理计划可能依赖于处理的数据的物理格式（例如，排序、压缩）。
- 逻辑计划到物理计划并不总是存在一对一的映射。

一条 SQL 语句运行整体架构图：

![](pics/Pasted%20image%2020231012132749.png)
- 应用程序连接到数据库系统并发送 SQL 查询，该查询可能会被重写成不同的格式。
- SQL 字符串被解析成组成语法树的标记。
- 绑定程序通过查阅系统目录将语法树中的命名对象转换为内部标识符。
- 绑定程序生成一个逻辑计划，该计划可以提供给树重写程序获取额外的模式信息。
- 然后，逻辑计划交给优化器，优化器选择执行计划的最有效过程。
## 2 Logical Query Optimization

一些选择性优化包括：  
• 尽早执行过滤操作（谓词下推）。  
• 重新排列谓词，以便 DBMS 首先应用最具选择性的谓词。  
• 将复杂谓词拆分并下推它（分解合取谓词）。

![](pics/Pasted%20image%2020231012132906.png)

图 2 是谓词下推的一个示例，在连接之前通过过滤操作符，可以减少连接运算需要传递的操作符数量。

一些投影优化包括：
- 在尽早的阶段执行投影，以创建更小的元组并减少中间结果（投影下推）。  
- 投影只保留请求需要的属性（列裁剪）。

![](pics/Pasted%20image%2020231012133146.png)

图 3 是投影下推，查询值请求学生姓名和 ID，所以可以移除其他的列，再进行连接运算。

一些查询重写优化包括：  
• 移除不可能或不必要的谓词。在这种优化中，DBMS 省略了对谓词的评估，因为它们在表中的每个元组上的结果不会改变。绕过这些谓词可以减少计算成本。  
• 合并谓词，如图 4 所示。  
• 通过取消关联性和/或展开嵌套子查询来重写查询。图 5 中有一个示例。  
• 分解嵌套查询并将结果存储到临时表中。图 6 中有一个示例。

![](pics/Pasted%20image%2020231012133535.png)

图 4 展示的是合并谓词，将两个谓词条件合并成一个。

![](pics/Pasted%20image%2020231012133608.png)

图 5 展示的是通过将子查询重写为连接运算，前一个查询可以重写为后一个查询。以这种方式移除嵌套层级可以有效地展平查询。

![](pics/Pasted%20image%2020231012133720.png)

对于具有子查询的复杂查询，DBMS 的优化器可能会将原始查询分解为块，并侧重于逐个优化每个单独的块。图 6 中，优化器通过将嵌套查询提取到自己的查询中来分解具有嵌套聚合的查询，然后使用此结果来实现原始查询的逻辑。

连接操作的顺序是查询性能的关键决定因素。对所有可能的连接顺序进行详尽枚举是低效的，因此连接顺序的优化需要一个成本模型。然而，我们仍然可以通过启发式方法来消除不必要的连接。图 7 中展示了连接消除的一个示例。

![](pics/Pasted%20image%2020231012134128.png)

## 3 Cost Estimations

DBMS 使用成本模型来估算执行计划的成本。这些模型评估查询的等效计划，以帮助 DBMS 选择最优的计划。查询的成本取决于几个基本的度量指标：  
• CPU：成本较小，但难以估算。  
• 磁盘 I/O：块传输的数量。  
• 内存：使用的 DRAM 数量。  
• 网络：发送的消息数量。

对于一个查询来说，穷举所有有效计划的可能性对于优化器来说速度太慢了。仅考虑连接操作，这些操作是可交换和可结合的，对于每个 n 路连接，有 $4^n$ 种不同的顺序。为了高效工作，优化器必须限制其搜索空间。

为了估算查询的成本，DBMS 会维护有关其内部目录中的表、属性和索引的内部统计信息。不同的系统以不同的方式维护这些统计信息。大多数系统都会尝试通过维护内部的统计信息表来避免即时计算。然后，这些内部统计信息表可能会在后台进行更新。

对于每个关系 R，DBMS 会维护以下信息：  
• NR：关系 R 中的元组数目。  
• V(A, R)：属性 A 在关系 R 中的不同值的数量。

根据上面列出的信息，优化器可以推导出选择基数 (selection cardinality) SC(A, R) 统计量。选择基数是属性 A 的平均值，假定已知 NR / V(A,R)。需要注意的是，这个假设假定了数据的均匀性，这种假设通常是不正确的，但它简化了优化过程。

### Selection Statistics

选择基数可以用来确定对于给定输入将选择多少个元组。对于唯一键上的等式谓词很容易估算（参见图 8）。图 9 中显示了一个更复杂的谓词。

![](pics/Pasted%20image%2020231012134617.png)

图 8 中因为 ID 是唯一的主键，所以很容易估算元祖的大小，大概为 1。而图 9 中复杂的查询语句就很难估计元祖的大小了。

谓词 P 的选择性（sel）是符合条件的元组占总元组数的比例。计算选择性的公式取决于谓词的类型。复杂谓词的选择性很难准确估算，这可能会对某些系统造成问题。选择性计算的示例如图 10 所示。

![](pics/Pasted%20image%2020231012134926.png)

否定查询的选择性是通过从 1 中减去肯定查询的选择性来计算的。在示例中，答案为 4/5。

注意，谓词的选择性等同于谓词的概率。这允许在许多选择性计算中应用概率规则。这在处理复杂谓词时特别有用。例如，如果我们假设与合取相关的多个谓词是独立的，那么我们可以将合取的总选择性计算为各个谓词选择性的乘积。

### Selectivity Computation Assumptions

在计算谓词的选择基数时，通常使用以下三个假设：
- 数据均匀性（Uniform Data）：值的分布（除了重要值之外）是相同的。  
- 独立谓词（Independent Predicates）：属性上的谓词是相互独立的。  
- 包含原则（Inclusion Principle）：连接键的域重叠，使内部关系中的每个键也存在于外部表中。

这些假设通常不适用于真实数据。例如，相关的属性会打破谓词独立性的假设。

## 4 Histograms

真实数据通常不均匀，并且很难对其进行假设。然而，存储数据集的每个值都是昂贵的。通过将数据存储在直方图（Histograms）中，将值分组在一起是降低内存使用的一种方法。图 11 中显示了带有桶的示例图。

另一种方法是使用等深度直方图，它会变化桶的宽度，以使每个桶的总出现次数大致相同。图 12 中显示了一个示例。

一些系统可能会使用草图 (sketches) 来生成关于数据集的近似统计信息，以替代直方图。

![](pics/Pasted%20image%2020231012135525.png)

## 5 Sampling

DBMS 可以使用抽样（Sampling）来将谓词应用于表的一个较小副本，该副本具有类似的分布（参见图 13）。当底层表的更改量超过某个阈值时（例如，元组的 10%），DBMS 会更新样本。

![](pics/Pasted%20image%2020231012135744.png)

DBMS 可以从原始表的子集中来估计谓词的选择性，而不是使用表中的十亿个值来估算选择性。

## 6 Plan Enumeration

在执行基于规则的重写之后，DBMS 会列举不同的查询计划并估算它们的成本。然后，在耗尽所有计划或经过一定时间后，它会选择最佳的计划用于查询。

## 7 Single-Relation Query Plans

对于单关系查询计划，选择最佳的访问方法（例如，顺序扫描、二分搜索、索引扫描等）是最大的障碍。大多数新的数据库系统仅使用启发式方法，而不是复杂的成本模型，来选择访问方法。

对于 OLTP 查询，这特别容易，因为它们是可搜索的（Sargable，Search Argument Able）。这也可以用简单的启发式方法来实现。

## 8 Multi-Relation Query Plans

在多关系查询计划中，随着连接数量的增加，备选计划的数量迅速增长。因此，重要的是限制搜索空间，以便能够在合理的时间内找到最优计划。有两种方法来解决这个搜索问题：

- 自下而上（Bottom-up）：从零开始，然后构建计划以达到所需的结果。示例：IBM System R、DB2、MySQL、Postgres、大多数开源 DBMS。
- 自上而下（Top-down）：从你想要的结果开始，然后向下搜索树以找到实现目标的最优计划。示例：MSSQL、Greenplum、CockroachDB、Volcano。

## 9 Bottom-up optimization example - System R

使用静态规则进行初始优化。然后，使用动态规划来确定表的最佳连接顺序。
- 将查询拆分成块，并为每个块生成逻辑运算符。  
- 对于每个逻辑运算符，生成实现它的一组物理运算符。  
- 然后，迭代构建一个“左深”树，以最小化执行计划的估算工作量。

## 10 Top-down optimization example - Volcano

从一个逻辑计划开始，确定我们想要的查询内容。通过将逻辑运算符转化为物理运算符，执行一个分支限界搜索以遍历计划树。
- 在搜索过程中跟踪全局最佳计划。
- 在规划过程中将数据的物理特性视为第一类实体。
