## MySQL 锁有哪些

MySQL 当中根据加锁的范围，可以分为全局锁、表级锁和行锁三种。

1. **全局锁**

- 全局锁相当于对整个数据库进行加锁，使用全局锁之后，**整个数据库处于只读状态**，其他线程执行任何的增删改以及修改表的结构都会阻塞。
- 全局锁应用场景是**全库逻辑备份**，备份数据库的时候，不会因数据或表的更新导致备份之后的数据和预期不一致的问题。
- 全局锁缺点：整个数据库只读，如果备份比较耗时，备份期间，业务只能读数据，不能更新数据，导致业务停滞。
- 如何避免备份的时候业务停滞的问题：对于支持**可重复读隔离级别**的存储引擎来说，备份数据库之前开启事务，由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。

1. **表级锁**：表级锁又分为表锁、元数据锁（MDL）、意向锁；

- **表锁**：是对某个数据表进行加锁，分为读锁和写锁，**表锁不仅会限制其他线程对这个表读写，也会限制本线程接下来的读写操作**。

```mysql
//表级别的共享锁，也就是读锁；
lock tables t_student read;

//表级别的独占锁，也就是写锁；
lock tables t_stuent write;

// 解锁
unlock tables
```

- **元数据锁（MDL）**：不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL，**MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更**。
	- 对一张表进行 CRUD 操作时，加的是 **MDL 读锁**；
	- 对一张表做结构变更操作的时候，加的是 **MDL 写锁**；

- **意向锁**：在 InnoDB 引擎中，对某些记录加上共享锁/独占锁之前，会先在表级别加上一个**意向共享锁/意向独占锁**。
	- **意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（_lock tables ... read_）和独占表锁（_lock tables ... write_）发生冲突。**
	- 意向锁作用是**为了快速判断表当中是否有记录被加锁**，因为表锁和行锁之间是可能会发生冲突的：
		- 如果没有意向锁，对表加独占表锁的时候，需要遍历所有记录查看是否加了行锁，效率很慢；
		- 有意向锁之后，一条记录加独占锁的时候，会先在表级别上加上意向独占锁，这样如果在给这个表加上独占表锁的时候，就会和意向锁冲突；

3. **行级锁**

- Record Lock，记录锁，也就是仅仅把一条记录锁上，记录锁也是分为共享锁和独占锁的。
- Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身，只存在于可重复读隔离级别，目的是为了**解决可重复读隔离级别下幻读的现象**。
- Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。

