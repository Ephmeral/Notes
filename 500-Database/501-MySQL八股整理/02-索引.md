## 00 B 树和 B+ 树

### 二叉搜索树（Binary Search Tree）

二叉搜索树：
- 1）所有非叶子结点至多拥有两个儿子（Left 和 Right）；
- 2）所有结点存储一个关键字；
- 3、非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；

二叉搜索树关键性质是：中序遍历得到的结果必然是单调非降的

![](pics/Pasted%20image%2020240110121939.png)

### B 树（B-Tree）

B 树是一种多路搜索树（并不是二叉的）：
- 1）任意非叶子节点最多只有 M 个孩子节点，且 M > 2；
- 2）根节点的孩子节点数为 [2, M]，除根结点以外的非叶子结点的儿子数为 [M/2, M]；
- 3）每个内部节点存放至少 M/2-1（取上整）和至多 M-1 个关键字，同时指向孩子节点分支数量至少为 M/2 - 1，至多为 M 个；
- 4）非空的 B 树当中，根节点的指向孩子节点的分支数量至少为 2，至多为 M；
- 5）B 树是高度平衡的， 即所有叶子结点位于同一层；

![](pics/Pasted%20image%2020240110124210.png)

### B+ 树（B+Tree）

B+ 树是 B 树的变体，也是多路平衡搜索树：
- 1）其定义基本与 B 树相同，除了：
- 2）非叶子结点的指向孩子节点指针与关键字个数相同；
- 3）每个叶子节点都有指向相邻节点的指针；
- 4）所有关键字都在叶子结点出现；

下面是一个 M=3 的 3 阶 B+ 树（这里没有显示叶子节点指向的数据）：

![](pics/Pasted%20image%2020240110125248.png)

B+ 树和 B 树对比：

- 1）B 树和 B+ 树搜索的时候，过程类似，但是对于 B 树来说可能在非叶子节点搜索就结束了，而 B+ 树的关键码只存放在叶子节点上，也就是 B+ 树搜索只会在叶子节点结束。
- 2）B+ 树的内部节点不存放数据，相较于 B 树内部节点也存放数据来说，B+ 树内部节点可以存放更多的键，这样对于 B+ 树来说更加的矮胖。
- 3）B+ 树叶子节点有指向相邻节点的指针，可以进行顺序扫描，B 树无法做到。

B+ 树和 B 树性能对比：

- 1）**单点查询**：B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+ 树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O 次数会更少。
- 2）**插入和删除效率**：B+ 树有冗余节点，删除的时候树的结构变化很小，而 B 树不存在冗余节点，删除一个节点可能会导致树的结构发生变化，插入也是类似，所以 B+ 树的插入删除效率更加的高。
- 3）**范围查询**：B+ 树叶子节点之间还有链表，所以可以支持范围查询，对于大量数据查询的时候涉及多个磁盘 IO 查询，B+ 树的效率会 B 树高。

## 01 索引分类

**索引**：是一种用于加速对数据库表中数据的检索和排序操作的数据结构。索引类似于书籍的目录，通过在数据库表的一个或多个列上创建索引，可以更快地找到符合特定条件的行，从而提高查询性能。

索引可以按照不同的分类：
- 按「数据结构」分类：**B+tree 索引、Hash 索引、Full-text 索引**。
- 按「物理存储」分类：**聚簇索引（主键索引）、二级索引（辅助索引）**。
- 按「字段特性」分类：**主键索引、唯一索引、普通索引、前缀索引**。
- 按「字段个数」分类：**单列索引、联合索引**。

### 数据结构划分

从数据结构来看，分为 B+Tree 索引、HASH 索引、Full-Text 索引。  

![](pics/Pasted%20image%2020240110105959.png)

InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎，B+Tree 索引类型也是 MySQL 存储引擎采用最多的索引类型。在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：

- 如果有主键，默认会使用主键作为聚簇索引的索引键（key）；
- 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；
- 在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；

其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。**创建的主键索引和二级索引默认使用的是 B+Tree 索引**。

B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是**按主键顺序存放**的。

#### 为什么是 B+ 树而不是 B 树？

上面我们提到的 B+ 树所完成的工作，B 树也能完成？为什么 MySQL 中的索引大多使用 B+ 树而不是 B 树呢？有以下几个原因：

- 首先 B+ 树的**空间利用率更高**（非叶节点没有 data 域），可减少 IO 次数，磁盘读写所耗费的代价更低；
- B+ 树的**查询效率更加地稳定**，B 树搜索在非叶子节点还是叶子节点结束都有可能，越靠近根节点，查找效率越快；而 B+ 树无论查找的是什么数据，最终都需要从根节点一直走向叶节点，所有查找所经过的次数都是一样的；
- B+ 树能**同时支持随机检索和顺序检索**，而 B 树只适合随机检索，顺序检索的效率比 B+ 树低；
- 增删文件时，B+ 树的效率更高，因为所有的 data 都在叶子节点中，而 B 树删减节点时还需要分裂，中间节点向上等操作；

补充：索引只有叶子节点有数据，这个有什么影响？
- 这个问题其实就是在问为什么需要用 B+ 树，而不是 B 树
#### 为什么不用 Hash 索引呢？

Hash 索引更容易理解，底层就是 Hash 表，调用一次 hash 函数就可以直接确定相应键值，之后进行回表查询实际数据，按理说 Hash 索引比 B+ 树还高效？为什么不使用 Hash 索引呢？原因有以下几点：

- Hash 索引**不支持区间查找**，类似 `select * form table where age > 10` 这种查找，对于 Hash 来说，XX；
- Hash 索引**不支持模糊查询**，像 `JoinX` 和 `JoinA` 之间没有关联性，原因在于 Hash 函数的不可预测；
- Hash 索引在等值查询上很快，但是**却不稳定**，hash 索引还有一个重要的问题，hash 碰撞，**当发生 hash 碰撞时，某个键值大量重复时，效率变得极差**；

### 物理存储划分

从物理存储的角度来看，索引分为聚簇索引（主键索引）、二级索引（辅助索引）。
- 聚簇索引的 B+Tree 的叶子节点存放的是**实际数据**，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里，**找到索引也就找到了数据**；聚簇索引不是一种单独的索引类型，而是**一种数据的存储方式，聚簇索引的顺序，就是数据在硬盘上的物理顺序**。
- 辅助索引的 B+Tree 的叶子节点存放的是**主键值**，而不是实际数据。

查询二级索引的时候，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是**覆盖索引**。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是**回表**。

### 字段特性划分

从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。
1. **主键索引**：建立在主键字段上的索引，通常和建表一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。
2. **唯一索引**：建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。
3. **普通索引**：建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。
4. **前缀索引**：对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。

### 字段个数划分

从字段个数的角度来看，索引分为单列索引、联合索引（复合索引）。

- 建立在单列上的索引称为单列索引，比如主键索引；
- 建立在多列上的索引称为联合索引；

## 02 最左匹配原则

**最左匹配原则**：就是在联合索引当中，会按照最左优先的方式进行索引的匹配。

比如创建一个 `(a, b, c)` 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：
- where a=1；
- where a=1 and b=2；
- where a=1 and b=2 and c=3；

但是如果查询条件是以下情况，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效：
- where b=2；
- where c=3；
- where b=2 and c=3；

因为 `(a, b, c)` 联合索引是先按照 a 排序，a 相同情况下再排序 b，然后再排序 c，所以**b 和 c 是全局无序，局部相对有序的**，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。

有个例外是：当你 select 的字段里有复合索引里的字段，那么 where 语句不需要满足最左前缀匹配，MySQL 也会走索引。 比如：`select a from demo_table where b = "xxx";` 这个时候走索引是通过**索引覆盖**来减少对数据的检索。

另外在联合索引进行范围查询的时候：
- **在遇到范围查询（如 >、<）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引**。比如 `select * from t_table where a > 1 and b = 2` 其中 a 字段会用到联合索引，但是对于 a > 1 条件中 b 字段不是有序的，b 字段不会用上联合索引。
- **但是，对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配**，比如 `select * from t_table where a >= 1 and b = 2` 其中 a 字段会用到联合索引，虽然 a >= 1 条件中 b 字段是无序的，**但是对于符合 a = 1 的二级索引记录的范围里，b 字段的值是「有序」的**（因为对于联合索引，是先按照 a 字段的值排序，然后在 a 字段的值相同的情况下，再按照 b 字段的值进行排序）。
- 这部分详细建议看小林 coding 原文，比较清楚

## 03 什么时候需要/不需要索引

索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：

- 需要占用物理空间，数量越大，占用空间越大；
- 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；
- 会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。

#### 什么时候适用索引？

- 字段有唯一性限制的，比如商品编码；
- 经常用于 `WHERE` 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。
- 经常用于 `GROUP BY` 和 `ORDER BY` 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。

#### 什么时候不需要创建索引？

- `WHERE` 条件，`GROUP BY`，`ORDER BY` 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。
- 字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。
- 表数据太少的时候，不需要创建索引；
- 经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree 的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。

## 04 优化索引的方法

- 1）**前缀索引优化**：前缀索引是用字段字符串前几个字符建立索引，可以减少索引字段的大小，在一些大字符串的字段作为索引时，可以减小索引项的大小。缺点是：order by 无法用前缀索引，前缀索引无法作为覆盖索引使用；
- 2）**覆盖索引优化**：覆盖索引即查询的字段在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。**不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。**
- 3）**主键索引最好是自增的**：主键索引的数据被存放在 B+ 树的叶子节点上，同一个叶子节点内的数据是按照主键顺序存放的，当插入一条数据的时候，会根据主键插入到对应的叶子节点上。**使用自增主键，每次插入数据都是追加插入，不需要移动数据**，如果是非自增主键，每次插入数据都是随机的，比如插入到某个叶子节点的中间位置的时候，需要将后续的数据进行移动，还可能会导致页分裂，影响查询效率。
- 4）**索引最好设置为 NULL**：索引列存在 NULL 的时候导致优化器更加难以优化，NULL 是一个无意义的字段，还会占用物理内存，使用 NULL 的时候至少会占用一个字节空间来存放 NULL 值列表。
- 5）**防止索引失效**：一些场景索引失效的场景：
	- 使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%` 这两种方式都会造成索引失效；
	- 在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；
	- 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
	- 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

## 05 MySQL 单表为什么不建议超过 2kw？

MySQL 当中一个数据页大小为 16KB，除了用户实际数据之外，还有一些元数据等等，如下图：

![](pics/Pasted%20image%2020240112110840.png)

索引是用来加速数据的查询过程，索引页本身和数据页一样，也是 16KB，在索引页中记录的是页 (数据页，索引页) 的最小主键 id 和页号，以及在索引页中增加了层级的信息：

![](pics/Pasted%20image%2020240112111131.png)

B+ 树索引当中非叶子节点存放的是索引信息，而叶子节点实际存放的行数据，现在想假设：
- 非叶子节点内指向其他页的数量为 x
- 叶子节点内能容纳的数据行数为 y
- B+ 数的层数为 z

所以最终总共的数据为 $Total = x^{z - 1} \times y$
- x：非叶子节点当中，假设去掉索引页头部（约 1k），剩下 15KB 存放索引页数据，即主键和页号，假设主键为 BigInt(8byte)，页号 (4byte)，一条数据为 12byte，则 x=15 * 1024 / 12 ≈ 1280 行。
- y：叶子节点也是同样存放数据大概 15KB，假设一行记录为 1KB 的话，则 y = 15 条数据。
- 假设 B+ 树是两层，那就是 z = 2，$Total = （1280 ^1 ）\times 15 = 19200$
- 假设 B+ 树是三层，那就是 z = 3， $Total = （1280 ^2） \times 15 = 24576000$ （约 2.45kw）

一般推荐 B+ 树是 3 层，如果层级越高，查询的磁盘 IO 次数会增多。前面只是大概分析，实际上行数据大小不同的情况下，最大的建议值也是不同的。

MySQL 为了提高性能，会将表的索引装载到内存中，在 InnoDB buffer size 足够的情况下，其能完成全加载进内存，查询不会有问题。但是，**当单表数据库到达某个量级的上限时，导致内存无法存储其索引，使得之后的 SQL 查询会产生磁盘 IO，从而导致性能下降**，所以增加硬件配置（比如把内存当磁盘使），可能会带来立竿见影的性能提升哈。

## 06 索引失效的情况

1. **对索引字段使用左模糊或左右模糊匹配**：
- 即用 `like %xx` 或者 `like %xx%` 这两种方式；
- 为什么左模糊匹配就会失效？因为 B+ 树是按照索引值有序排列的，只能根据前缀进行比较。
2. **对索引使用函数**：索引存放的是原字段的值，使用函数计算之后自然不会再走索引了。
3. **对索引使用表达式计算**：和上面是同样的道理，因为无法知道索引当中计算之后的值，只能将索引的值都取出来计算一遍。
4. **对索引隐式类型转换**：如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，索引就会失效，MySQL 遇见字符串和整数比较的时候，会自动将字符串转为整数，然后再进行比较，所以这里相当于想将索引字段转为整数，然后在比较，等同于前面对索引使用了函数，所以索引会失效。
5. **联合索引非最左匹配**：联合索引不满足最左匹配原则的时候，就会联合索引失效。
6. **where 子句当中的 OR**：在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。因为 or 是两个条件满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。

### 参考文献

[图解：什么是B树？（心中有 B 树，做人要虚心）一文读懂B-树 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/146252512)  
[B树详解与实现 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/463641767)  
[CodingLabs - MySQL索引背后的数据结构及算法原理](https://blog.codinglabs.org/articles/theory-of-mysql-index.html)  
[索引常见面试题 | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/mysql/index/index_interview.html#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95)

---

怎么进行索引调优?