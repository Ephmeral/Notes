## 事务的概念

**事务**：是一组数据库操作单元，被视为一个不可分割的工作单位。事务包含一系列的数据库操作，**这些操作要么全部执行，要么全部不执行**，保持数据库的一致性。

实现事务必须遵循一下的特性，即 ACID：
1. **原子性（Atomicity）：** 事务是一个原子操作单元，它要么全部执行成功，要么全部不执行。如果在事务执行的过程中发生错误，所有已经执行的操作都将被撤销，数据库回滚到事务开始前的状态。
2. **一致性（Consistency）：** 事务在执行前后，数据库的状态保持一致。这意味着事务的执行不会破坏数据库的完整性约束，数据库从一个一致的状态转移到另一个一致的状态。
3. **隔离性（Isolation）：** 多个事务可以并发执行，但每个事务的执行应该与其他事务相互隔离，以防止相互干扰。隔离性确保一个事务的执行不会对其他事务产生影响。
4. **持久性（Durability）：** 一旦事务成功地完成，其结果应该持久保存在数据库中，即使系统发生故障或重启，事务的结果也应该得以保留。

## 并行事务可能会导致什么问题？

MySQL 允许多个客户端连接，当多个事务同时执行的时候，可能会存在**脏读**、**不可重复读**、**幻读**的问题。

1. **脏读**：**如果一个事务读取到另外一个事务未提交的数据，就意味着发生了脏读**。比如 AB 事务同时处理，B 事务将某个人的账户减少 100，这个时候 A 事务读取到 B 事务减少后的余额，但是由于某些意外导致 B 事务需要将数据回滚，这样的话 A 事务读取的数据是过期的，不是 B 回滚后的数据。
2. **不可重复读**：**在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了不可重复读现象**。这种一般是 A 事务读取到一个数据之后，B 事务将这个数据更新了，然后 A 再次读取数据的时候，前后不一致，即不可重复读。
3. **幻读**：**一个事务内多次查询某个符合条件的记录数量，如果前后两次查询到的记录数量不一致，就发生了幻读**。这种情况比如 A 事务查询价格大于 100 的商品，第一次查询之后，B 事务插入了一条大于 100 的商品，并提交了事务，之后 A 事务再查询的时候，发现记录的数量多了一条，就出现了幻读。

## 事务的隔离级别

数据库的隔离级别是指在并发执行环境中，一个事务的执行是否与其他事务相互隔离，以及隔离的程度。SQL 标准提出了四种隔离级别，隔离级别越高，性能效率就越低，，它们是：

1. **读未提交（Read Uncommitted）：** 最低的隔离级别。一个事务可以读取另一个事务尚未提交的数据，可能导致脏读、不可重复读和幻读问题。
2. **读已提交（Read Committed）：** 一个事务只能读取已经提交的其他事务的数据。这可以解决脏读的问题，但仍可能存在不可重复读和幻读。
3. **可重复读（Repeatable Read）：** 保证在事务执行期间同一查询的结果保持一致，即使其他事务对数据进行了修改。这可以解决脏读和不可重复读的问题，但仍可能存在幻读。**MySQL InnoDB 引擎的默认隔离级别**；
4. **串行化（Serializable）：** 提供最高的隔离级别，确保事务之间完全隔离，不会发生脏读、不可重复读和幻读。这通常使用加锁的方式来实现，以防止其他事务对相同的数据进行修改。

四种隔离级别是如何实现的？

1. 读未提交：可以修改未提交事务的数据，每次读取最新的数据即可；
2. 串行化：通过加锁的方式来实现的；
3. 读已提交和可重复读：通过 Read View 来实现的，Read View 理解为一种快照，**「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View**。

## Read View 在 MVCC 中如何工作

![](pics/Pasted%20image%2020240107091320.png)

Read View 有四个重要的字段：

- m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的**事务 id 列表**，注意是一个列表，**“活跃事务”指的就是，启动了但还没提交的事务**。
- min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 **id 最小的事务**，也就是 m_ids 的最小值。
- max_trx_id ：这个并不是 m_ids 的最大值，而是**创建 Read View 时当前数据库中应该给下一个事务的 id 值**，也就是全局事务中最大的事务 id 值 + 1；
- creator_trx_id ：指的是**创建该 Read View 的事务的事务 id**。

![](pics/Pasted%20image%2020240107091425.png)

对于使用 InnoDB 存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：

- trx_id，当一个事务对某条聚簇索引记录进行改动时，就会**把该事务的事务 id 记录在 trx_id 隐藏列里**；
- roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后**这个隐藏列是个指针，指向每一个旧版本记录**，于是就可以通过它找到修改前的记录。

在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况：

![](pics/Pasted%20image%2020240107091552.png)

一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：

- 如果记录的 trx_id 值小于 Read View 中的 `min_trx_id` 值，表示这个版本的记录是在创建 Read View **前**已经提交的事务生成的，所以该版本的记录对当前事务**可见**。
- 如果记录的 trx_id 值大于等于 Read View 中的 `max_trx_id` 值，表示这个版本的记录是在创建 Read View **后**才启动的事务生成的，所以该版本的记录对当前事务**不可见**。
- 如果记录的 trx_id 值在 Read View 的 `min_trx_id` 和 `max_trx_id` 之间，需要判断 trx_id 是否在 m_ids 列表中：
    - 如果记录的 trx_id **在** `m_ids` 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务**不可见**。
    - 如果记录的 trx_id **不在** `m_ids` 列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务**可见**。

**这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。**

参考：[【数据库】MySQL的ReadView_read view 是怎么产生的-CSDN博客](https://blog.csdn.net/thesprit/article/details/112970122)

MVCC 当中可重复读和读提交是如何实现的？
- 「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。
- 「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。
