## MySQL 一条记录是如何存储的
### MySQL 的数据存放在哪个文件？

```mysql
mysql> SHOW VARIABLES LIKE 'datadir';
+---------------+-----------------+
| Variable_name | Value           |
+---------------+-----------------+
| datadir       | /var/lib/mysql/ |
+---------------+-----------------+
1 row in set (0.00 sec)
```

我电脑查看只有表名.ibd 文件，比如：
- person.ibd 文件，person 的表数据会保存在这个文件当中。
- 表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。
- 若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。

### 表空间文件的结构是怎么样的？

**表空间由段（segment）、区（extent）、页（page）、行（row）组成**，InnoDB 存储引擎的逻辑存储结构大致如下图：

![](pics/Pasted%20image%2020240104154140.png)

#### 1、行（row）

数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。

#### 2、页（page）

- 记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。
- 因此，**InnoDB 的数据是按「页」为单位来读写的**，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。**默认每个页的大小为 16KB**，也就是最多能保证 16KB 的连续存储空间。
- 页是 InnoDB 存储引擎磁盘管理的最小单元，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。
- 页的类型有很多，常见的有数据页、undo 日志页、溢出页等等。数据表中的行记录是用「数据页」来管理的。

#### 3、区（extent）

- InnoDB 存储引擎是用 B+ 树来组织数据的。B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有**大量的随机 I/O**，随机 I/O 是非常慢的。
- 解决这个问题也很简单，就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I/O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。
- **在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了**。

#### 4、段（segment）

表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。

- 索引段：存放 B + 树的非叶子节点的区的集合；
- 数据段：存放 B + 树的叶子节点的区的集合；
- 回滚段：存放的是回滚数据的区的集合，之前讲 [事务隔离 (opens new window)](https://xiaolincoding.com/mysql/transaction/mvcc.html) 的时候就介绍到了 MVCC 利用了回滚段实现了多版本查询数据。

### Compact 行格式

InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic 和 Compressed 行格式。第一种太古老，后面两种和 Compact 格式很像。这里重点看 Compact 行格式。

![](pics/Pasted%20image%2020240104154740.png)

#### 记录的额外信息

1. **变长字段长度列表**
- 对于变长字段来说，比如 varchar、text、blob 等字段，它们的长度是不固定的，存储数据的时候，还需要将数据占用的大小存放起来，存到「**变长字段长度列表**」里面，读取数据的时候才能根据这个「**变长字段长度列表**」去读取对应长度的数据。
- **当数据表没有变长字段的时候，比如全部都是 int 类型的字段，这时候表里的行格式就不会有「变长字段长度列表」了**，去掉这个还可以节省空间。

2. **NULL 值列表**
- 数据表当中的一些列可能存在 NULL 值，NULL 值存放在真实数据中会比较浪费空间。
- NULL 值列表，它采用的是二进制的思想，如果二进制位为 1，则代表该列为 NULL 值，否则不为 NULL。
- NULL 值列表占用一个字节（8 位，即最多 8 列），如果一条记录超过 9 个字段都是 NULL 的话，会创建 2 个字节的空间的 NULL 值列表。
- **当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了**。所以创建数据库表的时候，建议将字段设置为 NOT NULL，这样可以至少节省 1 字节的空间（NULL 值列表至少占用 1 字节空间）。

3. **记录头信息**

记录头信息中包含的内容很多，这里说几个比较重要的：

- delete_mask ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。
- next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。
- record_type：表示当前记录的类型，0 表示普通记录，1 表示 B+ 树非叶子节点记录，2 表示最小记录，3 表示最大记录

#### 记录的真实数据

记录的真实数据当中还有 3 个隐藏的字段：
- **row_id**：如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id 不是必需的，占用 6 个字节。
- **trx_id**：事务 id，表示这个数据是由哪个事务生成的。 trx_id 是必需的，占用 6 个字节。
- **roll_pointer**：这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节。
-  trx_id 和 roll_pointer 用在 MVCC 机制当中。

### varchar(n) 的 n 最多取多大？

首先 MySQL 规定：**除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节**。

一行记录的总长度最多是 65535 字节，varchar(n) 当中的 n 指的是存储的字符数量，不是字节大小。所以对于不同的字符集来说，结果也不一样。

假设是 ascii 字符集（一个字符占一个字节），数据库表当中只有一列，这个时候 varchar(n) 当中的 n 最多是多少？

- 一行记录除了真实数据大小，还包括变长字段长度列表以及 NULL 值列表，他们合起来最多为 65535。
- 上面情况下：变长字段长度列表占用字节为 2（因为这个变长字段允许存储的最大字节数大于 255 字节，需要 2 个字节才能存放的下这个长度）；
- 如果允许 NULL 值的话，NULL 值列表也占用一个字节，所以最终 n 最多为 65535 - 2 - 1 = 65532。

```mysql
CREATE TABLE test ( 
`name` VARCHAR(65532)  NULL
) ENGINE = InnoDB DEFAULT CHARACTER SET = ascii ROW_FORMAT = COMPACT;
```

### 行溢出后，MySQL 如何处理？

MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 `16KB`，也就是 `16384字节`，而一个 varchar(n) 类型的列最多可以存储 `65532字节`，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会**发生行溢出，多的数据就会存到另外的「溢出页」中**。

如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。在一般情况下，InnoDB 的数据都是存放在 「数据页」中。但是当发生行溢出时，溢出的数据会存放到「溢出页」中。

当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。大致如下图所示。

![](pics/Pasted%20image%2020240104162342.png)

上面为 Compact 行格式在发生行溢出后的处理。Compressed 和 Dynamic 这两个行格式和 Compact 非常类似，主要的区别在于处理行溢出数据时有些区别。这两种格式采用完全的行溢出方式，**记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。**

![](pics/Pasted%20image%2020240104162443.png)

## 一条 SQL 语句执行的流程

![](pics/Pasted%20image%2020240106165022.png)

1. **连接器**：首先客户端通过 TCP 与服务器建立连接，服务器会校验用户身份，管理客户端连接；
2. **查询缓存**：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；
3. **解析 SQL**，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；
4. **执行 SQL**：执行 SQL 共有三个阶段：
    - 预处理阶段：检查表或字段是否存在，将 `select *` 中的 `*` 符号扩展为表上的所有列；
    - 优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；
    - 执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；

## Buffer Pool

### 为什么要有 Buffer Pool？

MySQL 的数据是存放在磁盘当中的，如果每次都直接从磁盘读取数据，性能是极差的。为了提高查询的性能，InnoDB 存储引擎加了个**缓冲池（Buffer Pool）**，有了缓冲池之后：
- **读取数据的时候**，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。
- **写入数据的时候**，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后由后台线程将脏页写入到磁盘。

### Buffer Pool 大小是多大？

Buffer Pool 是在 MySQL 启动的时候，向操作系统申请的一片连续的内存空间，默认配置下 Buffer Pool 只有 `128MB` 。可以通过调整 `innodb_buffer_pool_size` 参数来设置 Buffer Pool 的大小，一般建议设置成可用物理内存的 60%~80%。

### Buffer Pool 缓存什么？

InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，Buffer Pool 同样需要按「页」来划分。

在 MySQL 启动的时候，**InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的 `16KB` 的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页**。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。

Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 undo 页，插入缓存、自适应哈希索引、锁信息等等。为了更好的管理这些在 Buffer Pool 中的缓存页，InnoDB 为每一个缓存页都创建了一个**控制块**，控制块信息包括「缓存页的表空间、页号、缓存页地址、链表节点」等等。

**查询一条记录，就只需要缓冲一条记录吗？**

- 查询一条记录的时候，会将整个页的数据都加载到 BufferPool 当中，索引只能定位到磁盘当中的页，不能定位到页当中的某条记录。
- 将页加载到 Buffer Pool 后，再通过页里的页目录去定位到某条具体的记录。

### 如何管理空闲页？

Buffer Pool 是一块连续的空间，MySQL 运行一段时间后，这块空间既有缓存页，也有未使用的空闲页，为了能够快速找到空闲的缓存页，可以使用链表结构，将空闲缓存页的「控制块」作为链表的节点，这个链表称为 **Free 链表**（空闲链表）。

![](pics/Pasted%20image%2020240109100317.png)

Free 链表有一个头结点，头结点包含链表头结点的地址，尾节点地址，以及链表节点数量等等。

### 如何管理脏页

设计 Buffer Pool 除了能提高读性能，还能提高写性能，也就是更新数据的时候，不需要每次都要写入磁盘，而是将 Buffer Pool 对应的缓存页标记为**脏页**，然后再由后台线程将脏页写入到磁盘。那为了能快速知道哪些缓存页是脏的，于是就设计出 **Flush 链表**，它跟 Free 链表类似的，链表的节点也是控制块，区别在于 Flush 链表的元素都是脏页。

![](pics/Pasted%20image%2020240109100455.png)

### 如何提高缓存命中率

Buffer Pool 的大小是有限的，对于一些频繁访问的数据我们希望可以一直留在 Buffer Pool 中，而一些很少访问的数据希望可以在某些时机可以淘汰掉，从而保证 Buffer Pool 不会因为满了而导致无法再缓存新的数据，同时还能保证常用数据留在 Buffer Pool 中。

最容易想到的就是 **LRU（Least recently used）算法**。
- 该算法的思路是，链表头部的节点是最近使用的，而链表末尾的节点是最久没被使用的。
- 当访问的页在 Buffer Pool 里，就直接把该页对应的 LRU 链表节点移动到链表的头部。
- 当访问的页不在 Buffer Pool 里，除了要把页放入到 LRU 链表的头部，还要淘汰 LRU 链表末尾的节点。

简单的 LRU 算法会导致**预读失效**和**Buffer Pool**污染问题。

#### 1. 预读失效：

- 程序是有空间局部性的，靠近当前被访问的数据，未来也大概率会被访问到。所以 MySQL 加载页的时候，会将相邻的数据页也加载到 Buffer Pool 当中。但是这是**提前加载到的数据页可能未被访问到，预读白做了，这就是所谓的预读失效**。
- 简单的 LRU 算法会将预读页放入 LRU 链表头部，Buffer Pool 空间不足的时候会将 LRU 尾部节点淘汰掉，这就导致如果预读页一直没被访问，但是它们却占用了 LRU 链表的头部位置，末尾淘汰的页，反而是频繁访问的页，大大降低了缓存命中率。

如何解决预读失效问题？MySQL 改进了 LRU 算法，将 LRU 划分了 2 个区域：**old 区域 和 young 区域**。

![](pics/Pasted%20image%2020240109101713.png)

- young 区域在 LRU 链表的前半部分，old 区域则是在后半部分，它们的比例可以通过 `innodb_old_blocks_pct` 参数来设置，默认是 37，代表整个 LRU 链表中 young 区域与 old 区域比例是 63:37。
- **划分这两个区域后，预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部**。如果预读的页一直没有被访问，就会从 old 区域移除，这样就不会影响 young 区域中的热点数据。

#### 2. Buffer Pool 污染

当某一个 SQL 语句**扫描了大量的数据**时，在 Buffer Pool 空间比较有限的情况下，可能会将 **Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了**，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 **Buffer Pool 污染**。

像前面这种全表扫描的查询，很多缓冲页其实只会被访问一次，但是它却只因为被访问了一次而进入到 young 区域，从而导致热点数据被替换了。young 区域就是热点数据，只需要增加进入 young 区域的门槛，就可以保证 young 区域的热点数据不会被替换掉。

MySQL 将进入到 young 区域条件增加了一个**停留在 old 区域的时间判断**。

- 对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问时间；
- 如果后续的访问时间与第一次访问的时间**在某个时间间隔内**，那么**该缓存页就不会被从 old 区域移动到 young 区域的头部**；
- 如果后续的访问时间与第一次访问的时间**不在某个时间间隔内**，那么**该缓存页移动到 young 区域的头部**；

这个间隔时间是由 `innodb_old_blocks_time` 控制的，默认是 1000 ms。**只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部**，这样就解决了 Buffer Pool 污染的问题 。

### 脏页什么时候刷盘？

修改数据的时候先修改 Buffer Pool 数据所在的页，然后设置为脏页，但是磁盘数据还是原来的，所以需要保证缓存和磁盘数据一致，需要将脏页刷入到磁盘当中，如果每次修改数据都刷入磁盘，会导致性能很差。所以会在一定时机进行批量刷盘。

如果脏页没刷入磁盘，MySQL 宕机了，数据是否会丢失？答案是不会，因为 InnoDB 的更新操作采用的是 **Write Ahead Log 策略**，即先写日志，再写入磁盘，通过 redo log 日志让 MySQL 拥有了崩溃恢复能力。

下面几种情况会触发脏页的刷新：
- 当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘；
- Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；
- MySQL 认为空闲时，后台线程会定期将适量的脏页刷入到磁盘；
- MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；

## 数据库三大范式

相关问题：
- 数据库中的三大范式
- 数据库表如何设计（应该是问三范式）  
- 对范式有哪些了解呢，范式的作用是什么
- 后端的业务系统是否适合范式理论

#TODO

## InnoDB 和 MyIsam 存储引擎区别

相关问题：
- 存储引擎有哪些 innodb 和 mysiam 存储一行数据有啥不同
- MySQL 引擎的区别（Mylsam，Innodb）
- 频繁的插入时 Innodb 的性能更好么（一次可以读到内存里更多）
- Innodb 写入时一定是往后追加么，在中间插入效率会更高么，为什么不用其他引擎
- MyISAM 和 InnoDB 区别

#TODO