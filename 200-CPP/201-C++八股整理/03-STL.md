## 0. STL 相关概念

这个好像没怎么见到问过，但是要知道 STL 有 6 大组件：内存分配器、容器、迭代器、适配器、算法和仿函数。

## 1. vector
### 1.1 vector 实现机制/原理

vector 是一种序列式容器，其数据安排以及操作方式与 array 非常类似，两者的唯一差别就是对于空间运用的灵活性，众所周知，array 占用的是静态空间，一旦配置了就不可以改变大小，如果遇到空间不足的情况还要自行创建更大的空间，并手动将数据拷贝到新的空间中，再把原来的空间释放。vector 则使用灵活的动态空间配置，维护一块**连续的线性空间**，在空间不足时，可以自动扩展空间容纳新元素，做到按需供给。其在扩充空间的过程中仍然需要经历：**重新配置空间，移动数据，释放原空间**等操作。这里需要说明一下动态扩容的规则：以原大小的两倍配置另外一块较大的空间（或者旧长度 + 新增元素的个数），源码：

```cpp
const size_type len  = old_size + max(old_size, n);
```

Vector 扩容倍数与平台有关，在 Win + VS 下是 1.5 倍，在 Linux + GCC 下是 2 倍

测试代码：

```cpp
#include <iostream>  
#include <vector>  
using namespace std;  
​  
int main()  {  
    //在 Linux + GCC 下  
    vector<int> res(2,0);  
    cout << res.capacity() <<endl; //2  
    res.push_back(1);  
    cout << res.capacity() <<endl;//4  
    res.push_back(2);  
    res.push_back(3);  
    cout << res.capacity() <<endl;//8  
    return 0;  
​  
​  
    //在 win 10 + VS2019 下  
    vector<int> res(2,0);  
    cout << res.capacity() <<endl; //2  
    res.push_back(1);  
    cout << res.capacity() <<endl;//3  
    res.push_back(2);  
    res.push_back(3);  
    cout << res.capacity() <<endl;//6  ​  
}
```

运行上述代码，一开始配置了一块长度为 2 的空间，接下来插入一个数据，长度变为原来的两倍，为 4，此时已占用的长度为 3，再继续两个数据，此时长度变为 8，可以清晰的看到空间的变化过程

需要注意的是，频繁对 vector 调用 push_back() 对性能是有影响的，这是因为每插入一个元素，如果空间够用的话还能直接插入，若空间不够用，则需要重新配置空间，移动数据，释放原空间等操作，对程序性能会造成一定的影响

### 1.2 vector 中动态扩容，那为什么是 1.5 倍或者是 2 倍？  

[[vector - 为什么是2倍扩容]]

vector 怎么扩容，假设按 2 倍扩容，给一个 vector1,初始化 reserve(10000) 和另一个 vector2，无操作，问对两个 vector 添加 10000 个元素，第二个比第一个多了多少个操作（等比数列求和）  

### 1.3 vector 的 push_back 与 emplace_back 的区别、使用场景、线程安全问题
- push_back 在插入数据的时候，会将对象的副本拷贝一份再插入到容器的末尾；
- 而 emplace_back 是 C++11 新引入的函数，它允许在容器的末尾直接构造元素，而不需要创建一个临时的副本。

使用场景：
- 使用 `push_back` 当你有一个已构造对象，并且想要将其副本添加到容器中。
- 使用 `emplace_back` 当你想要在容器末尾直接构造对象，并且可以直接提供构造该对象所需的参数。

这两个操作是线程安全的吗？ 如何实现线程安全？除了加锁还有其他方式吗？
- C++ 标准库并没有保证这两个操作是线程安全的。如果是多线程情况下，需要自行来确保线程安全性。
- 多线程一般通过：**互斥锁**来保证线程安全
- 除了互斥锁之外，还可以通过无锁的设计来实现线程同步。其中一种常见的思路就是 CAS(compare-and-swap)。**C++ 的原子变量**（atomic）就提供了 compare_exchange_weak 和 compare_exchange_strong 来实现 CAS 机制。
- 另外一个方式是通过 **thread_local** 变量来实现，thread_local 变量与其所在线程同步创建和销毁，并且只能被创建它的线程所访问，也就是说 thread_local 变量是线程安全的。每个线程在自身 TIB(Thread Information Block) 中存储 thread_local 变量的副本。

参考博客：[c++  三种 std::vector并发安全的设计思路](https://segmentfault.com/a/1190000041334904)

### 1.4 在 vector 尾部操作之后对迭代器有什么影响

使用 push_back 插入操作：  
- 这可能会导致迭代器失效，因为在 vector 尾部不停的插入新的元素话，可能会导致 vector 内部空间不足，需要重新进行扩容，而扩容之后，原有的值会拷贝到新的地址上，这样的话原来的迭代器就指向一块无效的空间了，这个时候再使用迭代器的话，就可能出现错误。

删除操作：
- 不会导致迭代器失效，因为只涉及到尾部元素，不会涉及到重新分配内存，所以迭代器不会失效。

### 1.5 resize()、reverse()、shrink_to_fit()

1. **resize():**
- **作用：** `resize()` 函数用于改变 `vector` 的大小，可以增加或减少元素的个数。如果新的大小比当前大小大，会在尾部插入新元素，并用默认值初始化；如果新的大小比当前大小小，则尾部的元素会被删除。
- **示例：

```cpp
std::vector<int> vec = {1, 2, 3}; 
vec.resize(5);  // 在尾部插入两个默认初始化的元素
```

2. **reserve():**
- **作用：** `reserve()` 函数用于预先分配 `vector` 的内存空间，但并不改变元素的个数。它可以避免插入元素时频繁触发内部的重新分配，提高效率。
- **示例：**

```cpp
std::vector<int> vec;
vec.reserve(100);  // 预先分配至少能容纳100个元素的内存空间
```

3. **shrink_to_fit():**  
- **作用：** `shrink_to_fit()` 函数用于请求删除 `vector` 多余的内存空间，使其大小等于元素的个数。但并不保证一定能够减小内存，具体取决于实现。通常，`shrink_to_fit()` 被调用后，`capacity()` 将等于 `size()`。
- **示例：**

```cpp
std::vector<int> vec = {1, 2, 3};
vec.shrink_to_fit();  // 可能减小内存，使 capacity() 等于 size()
```

**总结比较：**

- `resize()` 用于改变 `vector` 的大小，可以增加或减少元素的个数。
- `reserve()` 用于预先分配 `vector` 的内存空间，提高插入元素的效率。
- `shrink_to_fit()` 用于请求删除 `vector` 多余的内存空间，减小内存占用。

相关问题：如何让 vector 提前分配空间（调用 reverse() 函数）  
- 可以使用 `vector` 的 `reserve` 方法来提前分配空间，从而避免频繁的内部重新分配。`reserve` 方法用于确保 `vector` 至少具有指定数量的元素容量，但不改变实际元素的个数。

相关问题：vector 如何释放内存空间？怎么写  
- `shrink_to_fit()` 函数可以请求删除 `vector` 多余的内存空间，使其 `capacity()` 等于 `size()`。意，实际释放内存的成功与否是实现依赖的。

## 2. map/set/unordered_map/unordered_set
### 2.1 map、unordered_map 实现原理
from gpt：

`std::map` 使用红黑树（Red-Black Tree）作为其底层实现机制。红黑树是一种自平衡的二叉查找树，它确保在最坏情况下的查找、插入和删除操作的时间复杂度为 O(log n)。

红黑树的特点包括：

- 每个节点都带有颜色属性，红色或黑色。
- 根节点是黑色的。
- 所有叶子节点（NIL 节点）都是黑色的。
- 如果一个节点是红色的，则其两个子节点都是黑色的。
- 从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。

`std::unordered_map` 使用哈希表作为其底层实现机制。哈希表是一种将键映射到索引的数据结构，通过散列函数将键转换为数组的索引。具体的实现可能会涉及到以下关键概念：

- **桶（Buckets）：** 哈希表由一系列桶组成，每个桶存储一个链表或其他数据结构，用于解决哈希冲突。
- **散列函数：** 用于将键映射到桶的索引。好的散列函数能够均匀地分布键，减少冲突。
- **解决冲突：** 当两个键映射到相同的桶时，需要一种方法来处理冲突。常见的方法包括链地址法（用链表解决冲突）和开放寻址法（在冲突时探查下一个可用的桶）等。

哈希表的平均时间复杂度是 O(1)，但在最坏情况下，可能会变为 O(n)，其中 n 是元素的数量。这通常取决于哈希函数的质量和哈希表的装载因子（已存储元素数量与桶的数量的比率）。

### 2.2 map 和 set 的底层是红黑树，为什么要使用红黑树？

相关问题：讲一下红黑树和平衡树以及二叉搜索树的区别和优劣势？

查看博客：[map底层为什么用红黑树实现](https://blog.csdn.net/Ternence_zq/article/details/109821769#:~:text=AVL%20%E6%A0%91%E6%98%AF%E9%AB%98%E5%BA%A6%E5%B9%B3%E8%A1%A1%E7%9A%84%EF%BC%8C%E9%A2%91%E7%B9%81%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%EF%BC%8C%E4%BC%9A%E5%BC%95%E8%B5%B7%E9%A2%91%E7%B9%81%E7%9A%84rebalance%EF%BC%8C%E5%AF%BC%E8%87%B4%E6%95%88%E7%8E%87%E4%B8%8B%E9%99%8D%EF%BC%9B%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8D%E6%98%AF%E9%AB%98%E5%BA%A6%E5%B9%B3%E8%A1%A1%E7%9A%84%EF%BC%8C%E7%AE%97%E6%98%AF%E4%B8%80%E7%A7%8D%E6%8A%98%E4%B8%AD%EF%BC%8C%E6%8F%92%E5%85%A5%E6%9C%80%E5%A4%9A%E4%B8%A4%E6%AC%A1%E6%97%8B%E8%BD%AC%EF%BC%8C%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%9A%E4%B8%89%E6%AC%A1%E6%97%8B%E8%BD%AC%E3%80%82,%E6%89%80%E4%BB%A5%E7%BA%A2%E9%BB%91%E6%A0%91%E5%9C%A8%E6%9F%A5%E6%89%BE%EF%BC%8C%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E7%9A%84%E6%80%A7%E8%83%BD%E9%83%BD%E6%98%AFO%20%28logn%29%EF%BC%8C%E4%B8%94%E6%80%A7%E8%83%BD%E7%A8%B3%E5%AE%9A%EF%BC%8C%E6%89%80%E4%BB%A5STL%E9%87%8C%E9%9D%A2%E5%BE%88%E5%A4%9A%E7%BB%93%E6%9E%84%E5%8C%85%E6%8B%ACmap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E9%83%BD%E6%98%AF%E4%BD%BF%E7%94%A8%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E3%80%82)
#### 1、红黑树

红黑树是一种 [二叉查找树](https://so.csdn.net/so/search?q=%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91&spm=1001.2101.3001.7020)，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。  

通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱 [平衡二叉树](https://so.csdn.net/so/search?q=%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91&spm=1001.2101.3001.7020)，相对于要求严格的 AVL 树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。

**性质**：
1. 每个节点非红即黑
2. 根节点是黑的;
3. 每个叶节点（叶节点即树尾端 NULL 指针或 NULL 节点）都是黑的;
4. 如果一个节点是红色的，则它的子节点必须是黑色的。
5. 对于任意节点而言，其到叶子点树 NULL 指针的每条路径都包含相同数目的黑节点;
#### 2、平衡二叉树（[AVL树](https://so.csdn.net/so/search?q=AVL%E6%A0%91&spm=1001.2101.3001.7020)）

红黑树是在 AVL 树的基础上提出来的。

平衡二叉树又称为 AVL 树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过 1。

AVL 树中所有结点为根的树的左右子树高度之差的绝对值不超过 1。

将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子 BF，那么平衡二叉树上的所有结点的平衡因子只可能是 -1、0 和 1。只要二叉树上有一个结点的平衡因子的绝对值大于 1，则该二叉树就是不平衡的。

#### 3、红黑树较 AVL 树的优点

AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的 rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。

所以红黑树在查找，插入删除的性能都是 O(logn)，且性能稳定，所以 STL 里面很多结构包括 map 底层实现都是使用的红黑树。

#### 4、HashMap 和 TreeMap 底层实现的不同

C++ 中 unordered_map 的底层是用哈希表来实现的，通过 key 的哈希路由到每一个桶（即数组）用来存放内容。通过 key 来获取 value 的时间复杂度就是 O（1）。因为 key 的哈希容易碰撞，所以需要对碰撞做处理。unordered_map 里的每一个数组（桶）里面存的其实是一个链表，key 的哈希冲突以后会加到链表的尾部，这是再通过 key 获取 value 的时间复杂度就变成 O(n），当碰撞很多的时候查询就会变慢。为了优化这个时间复杂度，map 的底层就把这个链表转换成了红黑树，这样虽然插入增加了复杂度，但提高了频繁哈希碰撞时的查询效率，使查询效率变成 O(log n)。

#### 5、为什么使用红黑树而不是二叉搜索树

map，set 底层都提供了排序功能，红黑树形式存储的键值是有序的。同时红黑树可以在 O(log n) 时间内做插入，查找和删除。  

二叉搜索树并不一定是一颗平衡树，二叉搜索树（BST）只是左子树的值一定小于根节点，而右子树的值一定大于根节点。如果插入的值是有序的，那么构造出来的二叉树将是一个链表，它的时间复杂度将达到 O(n)。而使用红黑树，可以通过对每个节点标色的方式，每次更新数据后进行平衡，保证查找效率。

### 2.3 哈希冲突怎么处理

1. **开放寻址法（Open Addressing）**

在开放寻址法中，当发生哈希冲突时，算法会尝试找到下一个可用的哈希表位置，直到找到一个空槽或者达到某个条件为止。常见的开放寻址法包括：

- **线性探查（Linear Probing）：** 检查下一个槽，直到找到一个空槽。
- **二次探查（Quadratic Probing）：** 使用二次方程来计算下一个探查位置，以寻找下一个空槽。
- **双重散列（Double Hashing）：** 使用第二个哈希函数来计算下一个槽的位置。

在开放寻址法中，需要注意的是，删除操作相对复杂，通常需要特殊的标记来表示一个槽是否为空。  

2. **链地址法（Separate Chaining）**

在链地址法中，哈希表的每个槽都是一个链表，当发生哈希冲突时，新的元素会被插入到该槽对应的链表中。这样，具有相同哈希值的元素形成了一个链表。

链地址法的优势在于它相对简单，适用于动态数据集，因为每个槽的链表可以根据需要动态增长。然而，链表可能会导致缓存不命中，因为元素在内存中不是紧密排列的。

选择使用开放寻址法还是链地址法取决于具体的应用场景、数据集的特性以及对性能的要求。

其他注意事项：

- **装载因子（Load Factor）：** 装载因子是指已存储元素数量与哈希表槽的数量之比。当装载因子超过某个阈值时，可能需要进行哈希表的重新哈希，以保持性能。
- **好的哈希函数：** 使用一个好的哈希函数可以减少哈希冲突的发生。好的哈希函数应该尽可能均匀地分布键，减少冲突的概率。

### 2.4 你的哈希桶什么时候扩容？

一般而言，`std::unordered_map` 在装载因子达到某个阈值时会触发扩容。

装载因子（Load Factor）是指已存储元素数量与哈希表桶的数量之比。当装载因子超过一个设定的阈值，哈希表可能会触发扩容操作。通常，这个阈值在 0.7 到 0.8 之间，即当哈希表已存储的元素占据桶的大约 70% 到 80% 时进行扩容。

### 2.x 其他

假设现在自定义一个 class，使用这个 class 作为 unordered_map、map 的 key 要在类内做什么处理呢？
- 在 map 当中需要实现 `operator<()` 操作符重载，这样才能让 map 当中的键能够进行比较；
- 在 unordered_map 当中，需要实现 `operator==()` 操作符重载，这样能让键能够比较是否相等，除此之外还需要实现一个相应的哈希函数，来将键映射到对应的索引上。




## 4. list
### 4.1 list 的实现原理

相比于 vector 的连续线型空间，list 显得复杂许多，但是它的好处在于插入或删除都只作用于一个元素空间，因此 list 对空间的运用是十分精准的，对任何位置元素的插入和删除都是常数时间。list 不能保证节点在存储空间中连续存储，也拥有迭代器，迭代器的“++”、“--”操作对于的是指针的操作，list 提供的迭代器类型是双向迭代器：Bidirectional iterators。

list 节点的结构见如下源码：

```cpp
template <class T>  
struct __list_node{  
    typedef void* void_pointer;  
    void_pointer prev;  
    void_pointer next;  
    T data;  
}
```

从源码可看出 list 显然是一个双向链表。list 与 vector 的另一个区别是，在插入和接合操作之后，都不会造成原迭代器失效，而 vector 可能因为空间重新配置导致迭代器失效。

此外 list 也是一个环形链表，因此只要一个指针便能完整表现整个链表。list 中 node 节点指针始终指向尾端的一个空白节点，因此是一种“前闭后开”的区间结构

list 的空间管理默认采用 alloc 作为空间配置器，为了方便的以节点大小为配置单位，还定义一个 list_node_allocator 函数可一次性配置多个节点空间

由于 list 的双向特性，其支持在头部（front) 和尾部（back) 两个方向进行 push 和 pop 操作，当然还支持 erase，splice，sort，merge，reverse，sort 等操作，这里不再详细阐述。

### 2.2 list 查找、插入的时间复杂度

- list 的查找，如果是在头部或者尾部查找的话，时间复杂度为 O(1)，因为头尾有指针指向它们，可以直接访问；如果是在中间或者任意位置查找的话，时间复杂度为 O(n)，因为 list 是双向链表，它不支持随机下标访问，所以只能通过遍历链表来进行查找。
- list 的插入，从头部或者尾部插入的时间复杂度都是 O(1)，如果在中间某个位置插入，时间复杂度也是 O(1)，list 的插入只需要调整相邻节点的指针，还不需要移动元素，所以可以在常数时间内完成。
### 2.3 vector 与 list 的区别
from gpt：

1. **底层实现：**
- **`std::vector`：** 使用动态数组作为底层实现。动态数组是在内存中连续存储的，支持随机访问，因此对元素的随机访问效率很高。
- **`std::list`：** 使用双向链表作为底层实现。链表的每个元素包含指向前一个和后一个元素的指针，因此在链表中插入和删除元素的开销较小，但随机访问效率相对较低。

2. **内存分配：**
- **`std::vector`：** 动态数组的内存是连续分配的，这有助于提高缓存命中率，对于大规模的元素访问，`std::vector` 通常更有效。
- **`std::list`：** 链表的节点可以分散存储在内存中，这可能导致缓存不命中，从而影响性能。对于频繁的随机访问，`std::list` 可能不如 `std::vector` 高效。
3. 元素插入和删除：
- **`std::vector`：** 在中间或末尾插入或删除元素的开销较大，因为需要移动后续元素。在头部插入或删除元素也比较昂贵，因为需要移动整个数组。
- **`std::list`：** 插入和删除操作相对较为高效，因为只需要调整相邻节点的指针，不需要移动元素。
4. **迭代器的稳定性：**
- **`std::vector`：** 插入或删除元素可能导致指向元素的迭代器失效，因为需要移动元素。但如果不发生重新分配，尾部之前的迭代器仍然有效。
- **`std::list`：** 插入或删除元素对迭代器的影响较小，因为只需要调整指针。插入或删除操作不会影响其他元素的内存地址，因此对于 `std::list`，迭代器通常是稳定的。

## 5. deque
### 5.1 C++ 的 deque 的底层实现

vector 是单向开口（尾部）的连续线性空间，deque 则是一种双向开口的连续线性空间，虽然 vector 也可以在头尾进行元素操作，但是其头部操作的效率十分低下（主要是涉及到整体的移动）

![img](https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/1565876257552.png)

deque 和 vector 的最大差异一个是 deque 运行在常数时间内对头端进行元素操作，二是 deque 没有容量的概念，它是动态地以分段连续空间组合而成，可以随时增加一段新的空间并链接起来

deque 虽然也提供随机访问的迭代器，但是其迭代器并不是普通的指针，其复杂程度比 vector 高很多，因此除非必要，否则一般使用 vector 而非 deque。如果需要对 deque 排序，可以先将 deque 中的元素复制到 vector 中，利用 sort 对 vector 排序，再将结果复制回 deque

deque 由一段一段的定量连续空间组成，一旦需要增加新的空间，只要配置一段定量连续空间拼接在头部或尾部即可，因此 deque 的最大任务是如何维护这个整体的连续性

deque 的数据结构如下：

```cpp
class deque  
{  
    ...  
protected:  
    typedef pointer* map_pointer;//指向map指针的指针  
    map_pointer map;//指向map  
    size_type map_size;//map的大小  
public:  
    ...  
    iterator begin();  
    itertator end();  
    ...  
}
```

![img](https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/1565876324016.png)

deque 内部有一个指针指向 map，map 是一小块连续空间，其中的每个元素称为一个节点，node，每个 node 都是一个指针，指向另一段较大的连续空间，称为缓冲区，这里就是 deque 中实际存放数据的区域，默认大小 512bytes。整体结构如上图所示。

deque 的迭代器数据结构如下：

```cpp
struct __deque_iterator  
{  
    ...  
    T* cur;//迭代器所指缓冲区当前的元素  
    T* first;//迭代器所指缓冲区第一个元素  
    T* last;//迭代器所指缓冲区最后一个元素  
    map_pointer node;//指向map中的node  
    ...  
}
```

从 deque 的迭代器数据结构可以看出，为了保持与容器联结，迭代器主要包含上述 4 个元素

![img](https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/1565877658970.png)

deque 迭代器的“++”、“--”操作是远比 vector 迭代器繁琐，其主要工作在于缓冲区边界，如何从当前缓冲区跳到另一个缓冲区，当然 deque 内部在插入元素时，如果 map 中 node 数量全部使用完，且 node 指向的缓冲区也没有多余的空间，这时会配置新的 map（2 倍于当前 +2 的数量）来容纳更多的 node，也就是可以指向更多的缓冲区。在 deque 删除元素时，也提供了元素的析构和空闲缓冲区空间的释放等机制。

### deque 为什么要这么设计，好处是什么
from gpt：

1. **高效的头尾插入和删除：**
    - `std::deque` 允许在队列的两端进行高效的插入和删除操作，而且这些操作在常数时间内完成。这是因为 `std::deque` 内部采用了块状分配的结构，每个块中的元素是连续存储的。
    - 头尾插入和删除的常数时间复杂度是 `std::deque` 相对于 `std::vector` 的一个重要优势。
2. **动态增长：**
    - `std::deque` 具有动态增长的能力，当在两端插入元素时，它可以分配新的块以适应新增的元素。这允许 `std::deque` 在内部进行动态调整，以保持高效的头尾操作。
3. **低碎片：**
    - 由于 `std::deque` 采用块状分配，当块中的空间用尽时，可以分配一个新的块。这减少了内存碎片的问题，尤其是相较于动态数组实现的 `std::vector`，它可能需要重新分配整个数组，导致内存碎片。
4. **支持随机访问：**
    - 与 `std::list` 不同，`std::deque` 提供了类似于数组的随机访问能力。在常数时间内通过索引访问块内的元素，这使得 `std::deque` 在许多场景下更为适用。
5. **空间利用率：**
    - `std::deque` 在某些情况下相对于 `std::vector` 具有更好的空间利用率。由于它以块为单位分配内存，而不是一个连续的大数组，它可以更灵活地分配内存以适应元素的增长。

### deque 可以改用双向链表实现吗？

可以改成双向链表来实现，但是这样子的话，deque 就不再能提供随机访问的能力了，相比而言性能会有所降低。双向链表只能在头和尾实现高效的查找，但是对于中间位置，查找的时间复杂度为 O(n)。

## 6. 容器的对比

## 7. 迭代器
### 7.1 迭代器失效问题

**说说迭代器失效**  
8. 讲一讲迭代器失效以及解决方法

以 vector 为例：  
**插入元素：**
1. 尾后插入：size < capacity 时，首迭代器不失效尾迭代失效（未重新分配空间），size == capacity 时，所有迭代器均失效（需要重新分配空间）。
2. 中间插入：中间插入：size < capacity 时，首迭代器不失效但插入元素之后所有迭代器失效，size == capacity 时，所有迭代器均失效。

**删除元素：**
- 尾后删除：只有尾迭代失效。
- 中间删除：删除位置之后所有迭代失效。

deque 和 vector 的情况类似,

而 list 双向链表每一个节点内存不连续，删除节点仅当前迭代器失效，erase 返回下一个有效迭代器;

map/set 等关联容器底层是红黑树删除节点不会影响其他节点的迭代器，使用递增方法获取下一个迭代器 mmp.erase(iter++);

unordered_(hash) 迭代器意义不大，rehash 之后，迭代器应该也是全部失效。

### 7.2 STL 迭代器的实现原理？

## 8. 通用/宽泛的问题

1. 对 STL 挺熟悉的吗？那解释 vector、list、map、unordered_map 四个容器使用的场景和原理？  
2. stl 容器了解吗，详细叙述一下？
3. C++ 中的容器了解多少？
4. vector 与 array 的区别？
