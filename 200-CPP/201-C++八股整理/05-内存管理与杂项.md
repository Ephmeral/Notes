## 01 内存布局模型

![img](https://uploadfiles.nowcoder.com/images/20210329/675098158_1617011293853/7AFBB1602613EC52B265D7A54AD27330)

如上图，**从低地址到高地址，一个程序由代码段、数据段、BSS 段、堆栈段组成。**

1. **代码段**：存放程序**执行代码**的一块内存区域。只读，**不允许修改**，代码段的头部还会包含一些**只读的常量**，如**字符串常量字面值**（注意：**const 变量**虽然属于常量，但是本质还是变量，不存储于代码段）。
2. **数据段 data**：存放程序中**已初始化**的**全局变量**和**静态变量**的一块内存区域。
3. **BSS** 段：存放程序中**未初始化**的**全局变量**和**静态变量**的一块内存区域。
4. 可执行程序在运行时又会多出两个区域：**堆区**和**栈区。**
- **堆区**：动态申请内存用。堆从低地址向高地址增长。
- **栈区**：存储**局部变量**、**函数参数值**。栈从高地址向低地址增长。是一块连续的空间。
5. 最后还有一个**文件映射区（共享区）**，位于堆和栈之间。

### const int a = 10, a 和 10 存在哪个区？

直观感受 const 是存放在常量区的，但是实际上好像并不是。

>《C++ 编程思想》：  
> C++ 中的 const 默认为内部连接，也就是说，const 仅在 const 被定义过的文件里才是可见的，而在连接时不能被其他编译单元看到。当定义一个 const 时，必须赋一个值给它，除非用 extern 作出了清楚的说明。
>
> 通常 C++ 编译器并不为 const 创建存储空间，相反它把这个定义保存在它的符号表里。但是 extern 强制进行了存储空间分配（另外还有一些情况，如取一个 const 的地址，也要进行存储空间分配），由于 extern 意味着使用外部连接，因此必须分配存储空间，这也就是说有几个不同的编译单元应当能够引用它，所以它必须存储空间。

### 常量存储在什么地方？

1. **字面常量：**
- 字面常量是直接出现在源代码中的常量值，例如整数常量、浮点数常量、字符常量等。这些常量通常存储在程序的代码段（Code Segment）中，作为程序的一部分。

2. **const 和 constexpr 修饰的常量**：
- 它们通常存放在通常存储在程序的数据段（Data Segment）中。

## 02 堆和栈的区别

1. **堆、栈空间分配不同**。栈由操作系统自动分配释放 ，存放**函数的参数值**，**局部变量**的值等，栈有着**很高的效率**；堆一般由程序员分配释放，堆的**效率比栈要低的多**。
2. **堆、栈缓存方式不同**。栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些。
3. **空间大小：** 栈的空间大小并不大，一般最多为 2M，超过之后会报 Overflow 错误。堆的空间非常大，理论上可以接近 3G。（针对 32 位程序来说，可以看到内存分布，1G 用于内核空间，用户空间中栈、BSS、data 又要占一部分，所以堆理论上可以接近 3G，实际上在 2G-3G 之间）。
4. **能否产生碎片：** 栈的操作与数据结构中的栈用法是类似的。‘后进先出’的原则，以至于不可能有一个空的内存块从栈被弹出。因为在它弹出之前，在它上面的后进栈的数据已经被弹出。它是严格按照栈的规则来执行。但是堆是通过 new/malloc 随机申请的空间，频繁的调用它们，则会产生大量的内存碎片。这是不可避免地。

相关问题：栈为什么比堆快  
**堆跟栈，区别，经常什么情况下用堆，什么情况用栈**  
3.解释堆、栈，从数据结构和内存管理方面  
4.解释堆、栈再内存管理中实现的过程  

## 03 C++ 代码到程序执行过程
相关问题：
- c++ 代码到程序的执行过程。  
- 运行一个 exe 程序详细流程。
- `C++` 的编译从源码到可执行文件中间的步骤有哪些呢？
- 你了解 G++ 在编译的时候的 `o(1)`、`O(2)`、`O(3)` 这些优化有什么区别吗

from gpt：C++ 编译的过程从源码到可执行文件经历了多个步骤，主要包括预处理、编译、汇编、链接等阶段。以下是这些步骤的概述：
1. **预处理（Preprocessing）：**
    - 预处理阶段是在编译之前的一个独立阶段。主要任务包括处理 `#include` 指令，宏替换，条件编译（`#if`, `#ifdef`, `#ifndef` 等）等。预处理器会生成一个经过预处理的文件，通常以 `.i` 或 `.ii` 为扩展名。  
        `g++ -E source.cpp -o source.ii`
2. **编译（Compilation）：**
    - 编译阶段将预处理后的文件翻译成汇编语言。这个阶段产生的文件通常以 `.s` 或 `.asm` 为扩展名。编译器会对源代码进行语法分析、词法分析，生成汇编代码。  
        `g++ -S source.ii -o source.s`
3. **汇编（Assembly）：**
    - 汇编器将汇编代码翻译成机器码，生成目标文件。目标文件通常以 `.o`、`.obj`、`.co` 等为扩展名。  
        `g++ -c source.s -o source.o`
4. **链接（Linking）：**
    - 链接阶段将目标文件和库文件链接在一起，生成最终的可执行文件。链接器的任务包括解析符号引用、符号表的建立、地址重定位等。生成的可执行文件通常没有特定的扩展名。  
        `g++ source.o -o executable`

## 04 new/delete vs malloc/free

### 1. malloc/free 和 new/delete 的区别

简单对比：
1. **语法不同**：`malloc/free` 是一个 C 语言的函数，而 `new/delete` 是 C++ 的运算符。
2. **分配内存的方式不同**：`malloc` 只分配内存，而 `new` 会分配内存并且调用对象的构造函数来初始化对象。
3. **返回值不同**：`malloc` 返回一个 void 指针，需要自己强制类型转换，而 `new` 返回一个指向对象类型的指针。
4. malloc 需要传入需要分配的大小，而 new 编译器会自动计算所构造对象的大小

详细对比：

5. **申请内存所在位置**：new 是从自由存储区（free store）为对象分配内存空间，而 malloc 是从堆当中分配内存。自由存储区是 C++ 对 new 一个抽象，自由存储区一般是等价于堆的，主要取决于 operator new 的实现细节（可以是堆，也可以是静态存储区）。
6. **分配失败返回值**：new 内存分配失败时，会抛出 bac_alloc 异常，它不会返回 NULL；malloc 分配内存失败时返回 NULL。
7. **调用构造函数**：new 为对象分配内存的时候：1）调用 operator new，分配一块足够大的空间；2）编译器运行相应的构造函数来初始化对象；3）对象完成构造后，返回指向该对象的指针。delete 会调用析构函数之后，再 operator delete 释放空间。
8. **数组的处理**：C++ 的 new[] 和 delete[] 专门处理数组，在 new[] 的时候会依次调用构造函数来初始化对象，delete[] 会依次调用析构函数释放对象。malloc 只会分配一块空间，不会调用构造函数。
9. **能否重新分配内存**：malloc 分配内存的时候发现不足，可以使用 realloc 函数来重新分配内存实现内存的扩充。但是 new 没有这个机制。

### 2. malloc 实现原理？
- 当开辟的空间小于 128K 时，调用 brk() 函数；
- 当开辟的空间大于 128K 时，调用 mmap()。
- malloc 采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块连接，每一个空闲块记录了一个未分配的、连续的内存地址。

查看文章：[4.2 malloc 是如何分配内存的？ | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/os/3_memory/malloc.html#malloc-%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84)

问题：malloc 是如何跟物理地址关联上的？ free 一个对象指针中间发生了什么？ new 申请的内存可以 free 吗？

### 3. new 的实现原理？

`new` 和 `delete` 即是 C++ 关键字也是一种特殊的运算符。其中关键字 `new/delete` 和 `new[]/delete[]` 对内存的分配主要通过相应的运算符来实现。这些运算符的底层则也是通过调用库函数 `malloc/free` 来实现。

```cpp
void* operator new(size_t size);
void* operator new[](size_t size);
void  operator delete(void *p);
void  operator delete[](void *p);
```

除了调用 `operator new` 来分配内存之外，编译器还会调用对象的构造函数进行初始化，最后返回指向对象的指针。`delete` 则是先调用析构函数释放对象，再调用 `operator delete` 来释放相应的内存。

`new/delete` 可以进行重载，从而可以实现自定义内存池的方式来减少频繁使用 `new/delete` 导致的内存碎片、内存不足等问题。

**new/delete 运算符重载的一些规则**：

- new 和 delete 运算符重载必须成对出现
- new 运算符的第一个参数必须是 size_t 类型，delete 运算符的第一个参数则必须是要销毁释放的内存对象。
- 系统默认实现了 `new/delete`、`new[]/delete[]`、`placement new/delete` 6 个运算符函数。
- 当 delete 运算符的参数大于等于 2 时，就需要自己负责析构函数的盗用，并且以运算符函数的形式来调用 delete 运算符。

## 05 内存泄漏
### 1. 什么是内存泄漏？

简单地说就是申请了一块内存空间，使用完毕后没有释放掉。
- （1）new 和 malloc 申请资源使用后，没有用 delete 和 free 释放；
- （2）子类继承父类时，父类析构函数不是虚函数。
- （3）比如文件句柄、socket、自定义资源类没有使用对应的资源释放函数。
- （4）shared_ptr 共享指针成环，造成循环引用计数，资源得不到释放。

### 2. 内存泄漏怎么解决  

- （1）良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。
- （2）将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。
- （3）一些常见的工具插件可以帮助检测内存泄露，如 ccmalloc、Dmalloc、Leaky、Valgrind 等等。
- （4）使用智能指针。
- （5）采用 RAII 思想：**RAII（资源获取即初始化）** 是一种 C++ 编程范式，通过在对象的构造函数中获取资源（如内存），在析构函数中释放资源，来确保资源被正确管理。RAII 的使用可以避免忘记释放资源的问题。

### 3. 内存泄漏的原因

- 1. 最可能的就是我们程序员自己没注意，new 之后忘记 delete，或 malloc 之后忘记 free。
- 2. 异常提前返回：内存分配和释放都相应的配对写好了，但是程序中可能出现异常，导致提前返回，然后没有执行相应的 delete 或 free 语句。
- 3. 子类继承父类的时候，父类不是虚析构类函数，基类指针指向子类对象的时候，不会调用子类的析构函数，从而造成内存泄漏。
- 4. 使用智能指针 shared_ptr 不当，导致出现循环引用的问题，从而造成内存泄漏。

### 4. 内存溢出是什么？

**内存溢出**（Memory Overflow）是指程序试图访问超出其分配的内存范围的区域。
- 动态内存分配空间不足，导致内存溢出；
- 栈溢出，递归调用栈层次太深，或者局部作用域当中分配较大的局部变量；
- 缓冲区溢出，当程序向缓冲区写入超过其分配大小的数据时，可能会覆盖相邻的内存，导致内存溢出。

## 06 指针和引用
### 指针和数组的区别

**指针**：是一个变量，它的值为另一个变量的地址，通过指针可以访问内存中的数据。

**数组**：是一组相同类型的元素的集合，这些元素在内存中是连续存储的。

```cpp
int a = 42;
int *p = &a; // p是一个指针，存放的内容是变量a的地址

int arr[3] = {1, 2, 3}; // arr是一个大小为3，元素类型为int的数组
```

它们的区别是：
- **内存分配**：指针可以指向单个变量、动态分配的内存块或者数组的首元素，而数组是一块连续的内存空间。
- **大小和长度**：指针是一个变量，大小和系统架构有关。而数组的大小声明的时候就必须确定，而且是固定的。
- **操作**：指针可以通过算术运算进行移动，可以指向不同类型的数据，而数组的元素必须是相同类型，并且不能进行指针运算。
### 指针数组和数组指针

**指针数组**：指的是这个变量是一个数组，数组当中的存放的类型是指针。

```cpp
// 下面的p是一个大小为3的数组，数组元素类型为int*
int* p[3];
```

**数组指针**：这个变量本身是一个指针，它指向的类型是一个数组。

```cpp
// p本身是一个指针，指向的类型为大小为3的int类型数组
int (*p)[3];
```

下面是两者用法对比：

```cpp
#include <iostream>
using namespace std;

int main() {
    int a = 1, b = 2, c = 3;
    int* p[3];
    p[0] = &a;
    p[1] = &b;
    p[2] = &c;
    // p = 1 2 3
    std::cout << "p = " << *p[0] << " " << *p[1] << " " << *p[2] << std::endl;

    int d[3] = {0, 0, 0};
    int (*q)[3];
    q = &d; // q现在指向数组d
    (*q)[0] = a;
    (*q)[1] = b;
    (*q)[2] = c;
    // q = 1 2 3
    std::cout << "q = " << (*q)[0] << " " << (*q)[1] << " " << (*q)[2] << std::endl;
    // d = 1 2 3 可以看到修改(*q)[0]的内容之后，数组d当中的内容也随之修改
    std::cout << "d = " << d[0] << " " << d[1] << " " << d[2] << std::endl;
}
```

### 函数指针和指针函数

一个函数声明如下：

```cpp
// 函数只有一个参数类型为int，返回值为int
int p(int);
```

**函数指针**：是指向函数的指针变量。它存储函数的地址，可以用来调用该函数。

```cpp
// p与*先结合，所以p本身是一个指针，它指向的类型是有一个参数为int，且返回值为int的函数
int (*p)(int);

// 定义一个函数
int func(int x) {
	return x + 10;
}

p = &func; //p指向这个函数
cout << p(5) << endl; // 15
```

**指针函数**：是一个返回指针的函数，即函数的返回类型是一个指针类型。

```cpp
// 声明一个指针函数，返回值是指针类型
int* createArray(int size);

// 使用指针函数，获取动态分配的整数数组
int* arr = createArray(5);
```

### 指针和引用的区别

1. **概念上**：指针是一个变量，它保存了另一个变量的内存地址；引用是另一个变量的别名，与原变量共享内存地址。
2. **是否能修改**：指针可以被重新赋值，指向不同的变量；引用在初始化后不能更改，始终指向同一个变量。
3. **初始化**：指针可以为 nullptr，表示不指向任何变量；引用必须绑定到一个变量，不能为 nullptr。
4. **使用方式**：使用指针需要对其进行解引用以获取或修改其指向的变量的值；引用可以直接使用，无需解引用。
5. **二级指针**：有指针的指针，即二级指针甚至更多，但是没有引用的引用。
6. **自增（++）含义不同**：对于指针来说，自增 (++) 或自减 (--) 会进行指针运算，即移动指针所指向的地址，但是对于引用而言，作用在引用代表的对象上，对这个对象进行 ++ 或 --。

引用的应用场景有哪些？
- **函数参数传递**：引用传递参数，可以避免参数的拷贝，提示效率。
- **作为返回值**：函数可以返回一个引用，可以通过函数返回的引用修改调用者的变量。
- **简化指针操作**：引用相比于指针使用起来更加的简洁，可以替代指针，避免繁琐的解引用操作。

### 使用指针要注意什么？  

- 1. **空指针检查**：使用指针之前需要检查指针是否为空，防止空指针访问成员导致未定义行为。
- 2. **野指针**：避免使用未初始化的指针，可能包含随机的地址，导致不可预测的行为。
- 3. **空悬指针**：避免使用已经释放内存的指针，释放内存后可以将指针设为 nullptr。
- 4. **防止重复释放内存**：避免重复释放已经释放的内存，即 delete 两次指针。
- 5. **注意指针运算**：避免在非数组指针上执行指针算术运算，以防越界访问内存。
- 6. **考虑内存泄漏的问题**
- 7. **考虑采用 RAII 思想**：构造函数当中分配内存，在析构函数当中释放内存。
## 07 野指针和空悬指针
#### 1. 野指针

野指针指的是未初始化任何内容的指针（也没初始化为 NULL 指针）

```cpp
// wild_pointer.cpp
#include <iostream>

int main() {
	int *p; /* p是野指针 */
    // 下面直接访问*p对象会出错
    std::cout << *p << std::endl;

	int x = 10;
	// p现在不是野指针了
    p = &x;
    std::cout << *p << std::endl; // 10
	return 0;
}
```

#### 2. 悬空指针

**悬空指针**：指向已删除（或释放）的内存位置的指针。一般有三种情况导致悬空指针：

**2.1 释放 ptr 指向的内存**

```cpp
int* p = (int *)malloc(sizeof(int));

// free释放内存后，p是一个悬空指针
free(ptr);

// p置为NULL，不再是悬空指针
p = NULL;
```

**2.2 函数返回局部对象的地址**

```cpp
#include <iostream>

int* func() {
    int x = 10;
    // 返回x的地址，但是这个函数作用域结束后x对象的内存会被回收
    return &x; 
}

int main() {
    int *p = func(); // p是一个悬空指针

    std::cout << *p << std::endl; // 段错误
    return 0;
}
```

**2.3 变量离开作用域**

```c
// main.c
#include <stdio.h>

int main() {
    int *p;

    {
        int x = 10;
        p = &x;
    }
    // 离开作用域之后p是一个悬空指针
    // 但是下面代码实际还能正常运行
    printf("*p = %d\n", *p);
    return 0;
}
```

悬空指针所指向的内存被释放了，那么这个指针还存在吗？
- 当指针所指向的内存被释放后，该指针仍然存在，但它成为了悬空指针，其行为是未定义的。悬空指针可能包含之前指向的内存地址，但这块内存已经不再属于程序，可能已被操作系统收回。

## 08 C 内存分配方式有几种

这个问题乍一看好像不怎么怎么回答，但是实际上也是在问 C/C++ 内存布局，主要分为静态内存分配：包括全局/静态存储区、代码区，以及动态内存分配包括堆和栈。

**1. 内存分配的类型：**

在 C/C++ 中内存分为 5 个区，分别为**栈区、堆区、全局/静态存储区、常量存储区、代码区。**

**静态内存分配**：编译时分配。包括：全局、静态全局、静态局部三种变量。

**动态内存分配**：运行时分配。包括：
- 栈 (stack)： 局部变量。
- 堆 (heap)：C 语言中用到的变量被动态的分配在内存中。(malloc 或 calloc、realloc、free 函数)

**2. 变量的内存分配：**

**栈区（stack）**：指那些由编译器在需要的时候分配，不需要时自动清除的变量所在的储存区，如函数执行时，函数的形参以及函数内的局部变量分配在栈区，函数运行结束后，形参和局部变量去栈（自动释放）。栈内存分配运算内置与处理器的指令集中，效率高但是分配的内存空间有限。

**堆区（heap）**：指哪些由程序员手动分配释放的储存区，如果程序员不释放这块内存，内存将一直被占用，直到程序运行结束由系统自动收回，c 语言中使用 malloc，free 申请和释放空间。

**静态储存区（static）**：全局变量和静态变量的储存是放在一块的，其中初始化的全局变量和静态变量在一个区域，这块空间当程序运行结束后由系统释放。

**常量储存区（const）**：常量字符串就是储存在这里的，如“ABC”字符串就储存在常量区，储存在常量区的只读不可写。const 修饰的全局变量也储存在常量区，const 修饰的局部变量依然在栈上。

**程序代码区**：存放源程序的二进制代码。

C 和 C++ 内存分配有什么不同？

- 主要体现了 C++ 当中不再区分已初始化和未初始化静态变量和全局变量，它们都放在同一个称为全局/静态存储区。而 C 当中已初始化且不为 0 的全局/静态变量是放在 .data 段的，未初始化或值为 0 的全局/静态变量是放在 .bss 段的。
- 然后就是堆内存的分配方式上有所不同，C 通过 malloc/free，而 C++ 是通过 new/delete 来分配内存。

## 09 如何让一个对象只在栈（堆）上分配内存

简单概括一下：
- **只在栈中分配内存**，意味着不能通过 new 等方式动态分配内存，C++ 当中可以通过将 operator new 操作符函数设置为 private 的即可，因为 new 会分配内存的时候调用 operator new 操作符。
- **只在堆中分配内存**，首先对象创建在栈上面是由编译器分配内存的，**编译器为类对象分配内存的时候会检查析构函数是否可以访问，如果类的析构函数是私有的，那么编译器就不会在栈上为类对象分配内存**。所以只需要将类的析构函数设置为 private 即可。

```cpp
// 只能在栈当中分配内存，其实operator new[]和delete[]也需要设为private，不然可以分配数组的方式分配内存
class A  
{  
private:  
    void* operator new(size_t t){}     // 注意函数的第一个参数和返回值都是固定的  
    void operator delete(void* ptr){} // 重载了new就需要重载delete  
public:  
    A(){}  
    ~A(){}  
};

// 只在堆当中分配内存，
class B {
public:
    B() {}
    // delete无法访问私有析构函数，必须提供一个destroy函数释放内存
    void destroy() { delete this;}
private:
    ~B() {}
}
```

只在堆当中分配内存的问题：  
1. 无法解决继承问题：为了实现多态， 析构函数通常要设为 virtual， 因此析构函数不能设为 private，此时我们可以使用 protected， 这样，子类可以访问析构函数，而外部无法访问。
2. new 和 destroy 的对应关系容易引起误解，解决办法是将构造函数也设置为 protected，然后提供一个 create 函数和 destroy 对应。

---

- `malloc` 的时候操作系统会发生什么事情呢
- `malloc` 是怎么做到的呢，简单说一下原理呢