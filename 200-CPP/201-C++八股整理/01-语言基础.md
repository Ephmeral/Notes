## 01 sizeof 相关问题

### 1. 介绍一下 sizeof

在 C++ 中，`sizeof` 是一个用于获取数据类型或对象的大小（占用的字节数）的运算符。它返回一个 `size_t` 类型的值，表示在当前编译环境下该类型或对象所占用的内存大小。`sizeof` 运算符可以用于计算各种数据类型、变量、结构体、类等的大小。（from gpt）

### 2. sizeof 一个指针是什么结果？

sizeof 一个指针在不同的机器下结果不一样，指针的大小是固定的，如果是 64 位机器的话指针大小固定为 8 字节，如果是 32 位机器指针大小固定为 4 字节。

追加问题：为什么 32 位指针是 4 字节？
- 因为在 32 位机器当中，内存寻址是通过 32 位地址来完成了，指针是用来存储内存地址的变量，因此，一个 32 位指针就是一个 32 位的地址。

### 3. sizeof 数组是多少？sizeof 数组参数大小是多少？

- sizeof 一个数组，结果是数组的类型的大小 * 数组元素的个数；
- sizeof 数组参数的大小为 8，数组作为函数参数时会退化为指针，大小要按指针的计算。

### 4. sizeof 和 strlen 的区别

- strlen 是头文件中的**函数**，而 sizeof 是 C++ 中的**运算符**。
- strlen 是一个 C 标准库中的函数，用于计算 C 风格字符串（以空字符 '\0' 结尾的字符数组）的长度，即不包括结尾的空字符的字符个数。
- sizeof 是一个 C++ 编译期间计算的操作符，用于计算数据类型或对象所占用的字节数。

```cpp
#include <cstring>
#include <iostream>
using namespace std;

int main() {
  char str[] = "Hello World!";

  cout << "sizeof(str) = " << sizeof(str) << endl; // 13
  cout << "strlen(str) = " << strlen(str) << endl; // 12
}
```

### sizeof 一个空类大小是多少？为什么？

sizeof 一个空类的大小为 1，因为空类也可以实例化，每个实例化的对象在内存当中都有独一无二的地址，为了达到这个目的，编译器往往会给一个空类隐含的加一个字节，这样空类在实例化后在内存得到了独一无二的地址，所以 sizeof(A) 的大小为 1。

## 02 字节对齐

什么是字节对齐？为什么要字节对齐？

1. 为了使 CPU 能够对变量进行快速的访问，变量的起始地址应该具有某些特性，即所谓的“对齐”，比如 4 字节的 int 型，其**起始地址**应该位于 4 字节的边界上，即**起始地址能够被 4 整除**，也即“对齐”跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做**自然对齐**。

2. 为什么要字节对齐？  
	（1）需要字节对齐的根本原因在于 CPU 访问数据的**效率问题**。  
	（2）一些系统对对齐要求非常严格，比如 sparc 系统，如果取未对齐的数据会发生错误，而在 x86 上就不会出现错误，只是效率下降。  
	（3）各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些平台每次读都是从偶地址开始

## 03 const 关键字
### 1. 讲一下 const 的作用

const 主要用来修饰变量，函数以及指针，它的作用有以下几种：
- 1. **修饰变量**：此时变量视为只读变量，不能被修改；（下面的问题是如何修改这个变量）
- 2. **修饰函数**：可以用来修改函数的**参数**，表示函数不会修改这个参数，也可以修改函数的**返回值**，表示函数的返回值只读，不能被修改；
- 3. **修饰指针**：修饰指针有三种情况
	- 1）**指向只读变量的指针**：即 `const int *p;` ，此时指针本身可以修改（即改变指针的指向），但是指针所指向变量的内容是不能修改的；
	- 2）**只读指针**：即 `int * const p;`，此时指针本身不可以改变（即不能改变指针的指向），但是指针指向的变量内容是可以修改的；
	- 3）**只读指针指向只读变量**：上面两种情况的结合，`const int * const p;`，此时指针本身不可以修改，指针指向的变量也不可以修改；
- 4. **常量引用**：常量引用是指引用一个只读变量的引用，因此不能通过常量引用修改变量的值。
- 5. **修饰成员函数**：当 const 修饰成员函数时，表示该函数不会修改对象的状态（就是不会修改成员变量）
	- 这样的好处是 const 的对象就可以调用这些成员方法了，因为 const 对象不允许调用非 const 的成员方法；
	- 此外注意：const 的成员函数不能调用非 const 的成员函数，因为无法保证不会修改对象；

### 2. 如何修改 const 变量  

可以通过对 const 变量取地址，得到 `const int *p;`，然后通过 `const_cast` 强制类型转换去除 const 限制，最后通过强转后的指针来间接修改 const 变量的值。
- 但是注意，实际过程中编译器可能会进行优化，也就是说虽然修改了指针的值，但是打印输出 const 变量还是原来的值；
- 在上面的基础上，如果编译器进行优化的话，可以在 const 变量前面加上 **volatile** 关键字，这样可以阻止编译器进行优化，从而实现修改 const 变量的值。

```cpp
const int a = 10;
const int* p = &a;
int* q = const_cast<int*>(p);
*q = 20;  // 通过指针间接修改 const 变量的值
std::cout << "a = " << a << std::endl;  // 输出 a 的值，结果为 10

// 添加上volatile关键字
const volatile int a = 10;
const volatile int *cp = &a;
int *p = const_cast<int*>(cp);
*p = 20;
cout << "a = " << a << " *p = " << *p << endl; // a = 20 *p = 20
```

## 04 volatile 关键字
### 1. volatile 的使用

在 C 语言当中，使用 volatile 修改变量，表示该变量是易变的。这意味着，编译器不应该对该变量进行任何优化，而是应该每次都从内存中读取该变量的值。

```cpp
volatile int count = 0;
```

### 2. volatile 的作用
1. **防止编译器优化**
- 编译器会对变量进行优化，以提高程序的性能。例如，编译器可能会把一个变量的值缓存到寄存器中，以避免频繁地读写内存。
- 如果编译器对变量进行优化，可能会导致程序出现不可预测的错误。因此，使用 volatile 关键字可以告诉编译器不要对该变量进行优化，每次都要从内存中读取该变量的值。  
2. **指示变量可能被外部因素更改**：`volatile` 还可以用于声明变量，该变量可能被并发的线程、硬件中断或其他外部因素异步地更改。这种情况下，编译器会确保每次访问该变量时都会从内存中读取，而不使用缓存。
3. 但是 volatile 并不能用来进行多线程同步，需要用原子变量或 `std::mutex` 等机制来保证。
### 3. volatile 应用场景

一般说来，volatile 用在如下的几个地方：  
**1) 中断服务程序中修改的供其它程序检测的变量需要加 volatile；**  
**2) 多任务环境下各任务间共享的标志应该加 volatile；**  
**3) 存储器映射的硬件寄存器通常也要加 volatile 说明，因为每次对它的读写都可能由不同意义；**

参考文章：[C/C++ 中的 volatile - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/62060524)

## 05 字节序

1. 什么是大端序、什么是小端序？
- 字节序是指在多字节数据类型（如整数、浮点数等）中，字节在内存中的存储顺序。
- 大端序：**高**的有效字节存放在**低地址**处。
- 小端序：**低**的有效字节存放在**低地址**处。

```cpp
// 例如：x = 0x12345678
// 大端序
0x12 | 0x34 | 0x56 | 0x78

// 小端序
0x78 | 0x56 | 0x34 | 0x12
```

2. 如何判断一个系统是大端序，还是小端序？  
可以写一份代码，声明一个变量 x = 1，然后将其指针类型转为 char*，然后访问第一个字节，如果是 1 的话说明是小端存储的，否则为大端存储的。

```cpp
#include <iostream>
using namespace std;

int main() {
    int x = 0x1;
    char *p = reinterpret_cast<char*>(&x);
    if (*p == 1) {
        cout << "小端存储" << endl;
    } else {
        cout << "大端存储" << endl;
    }
}
```

另外也可以写一个联合体：存放一个 int 和 char 类型，然后给 int 赋值 0x12345678，如果是 char 类型打印结果为 0x78 说明是小端存储，为 0x12 为大端存储。

```cpp
#include <iostream>
using namespace std;

union A {
    int x;
    char c;
};

int main() {
    A a;
    a.x = 0x12345678;
    if (a.c == 0x12) {
        cout << "大端存储" << endl;
    } else if (a.c == 0x78) {
        cout << "小端存储" << endl;
    }
}
```

补充：
- 一般来说，网络传输都是大端存储，而常见的计算机系统（比如 Linux，Windows 和 Mac 都是小端存储），所以进行网络传输的时候需要进行字节序转换。

## 06 宏定义（define）和内联函数（inline）

### 1. 请你说说什么是宏？

`#define` 命令是一个宏命令，它用来将一个标识符定义为一个字符串，该标识符被称为宏名，被定义的字符串称为替换文本。该命令有两种格式：一种是不带参数的宏定义，另一种是带参数的宏定义。

一般定义宏主要有两个用途：1）定义常量；2）创建宏函数。

### 2. 为什么要少使用宏？C++ 有什么解决方案？

- 1）由程序编译的四个过程，知道**宏是在预编译阶段被展开的。在预编译阶段是不会进行语法检查、语义分析的**，宏被暴力替换，正是因为如此，如果不注意细节，宏的使用很容易出现问题。比如在表达式中忘记加括号等问题。
- 2）正因为如此，在 C++ 中为了安全性，我们就要少用宏。
	- 不带参数的宏命令我们可以用**常量 const**来替代，比如 `const int PI = 3.1415`，可以起到同样的效果，而且还比宏安全，因为这条语句会在编译阶段进行语法检查。
	- 而带参数的宏命令有点类似函数的功能，在 C++ 中可以使用**内联函数或模板**来替代，内联函数与宏命令功能相似，是在调用函数的地方，用函数体直接替换。但是内联函数比宏命令安全，因为内联函数的替换发生在编译阶段，同样会进行语法检查、语义分析等，而宏命令发生在预编译阶段，属于暴力替换，并不安全。

### 3. 请你说说内联函数，为什么使用内联函数？

- 1）内联函数和普通函数类似，只需要在函数名前面加上关键字 **inline**。
- 2）如果一个函数是内联函数，在编译的时候会把该函数的代码副本放到每个调用该函数的地方，但是实际上取决于编译器的实现，并不一定将所有的内联函数都进行内联。

**为什么使用内联函数？**

- 函数调用是有调用开销的，执行速度要慢很多，调用函数要先保存寄存器，返回时再恢复，复制实参等等。
- 如果本身函数体很简单，那么函数调用的开销将远大于函数体执行的开销。为了减少这种开销，我们才使用**内联函数**。

**类中的构造函数和析构函数可以是内联的吗？**
- 答案是可以的，因为你是有权建议任何函数为内联的，具体是否真的用内联函数取决于编译器的实现。
- 但是一般来说是不推荐将构造函数和析构函数作为内联函数的，因为编译器在编译期间会在构造函数和析构函数添加很多额外的代码，并不适合作为内联函数。

参考：[关于内联函数的几点总结以及构造析构是否可以是inline的_内联函数对构造函数的影响-CSDN博客](https://blog.csdn.net/u010150046/article/details/73823539)

### 4. 说说内联函数和宏函数的区别？

- 1）**语义**：宏定义在预处理阶段将宏进行展开，而预处理阶段只是简单的进行文本替换，不涉及类型检查；内联函数本质上是一个函数，编译器会尝试将内联函数的调用处用函数体进行替换，从而避免函数调用的开销。
- 2）**类型检查**：**宏定义**是没有类型检查的，无论对还是错都是直接替换；**而内联函数**在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等。
- 3）内联函数可以进行调试，宏定义的“函数”无法调试。
- 4）宏可能导致不合理计算：在 inline 函数传递参数只计算一次，而在使用宏定义的情况下，每次在程序中使用宏时都会计算表达式参数，因此宏会对表达式参数计算多次。 因为宏只是做替换，可能会把同样的表达式替换到多个地方。

```cpp
#include <iostream>
using namespace std;

#define MAX(a, b) ((a) > (b) ? (a) : (b))

inline int max(int a, int b) { return a > b ? a : b; }

int main() {
  int x = 1;
  int y = MAX(x++, 0); // 宏定义 x++ 会被执行两次, 因为 x++ 会被替换到两个地方

  int xx = 1;
  int yy = max(xx++, 0); // 内联函数没有这个问题

  cout << "x = " << x << " y = " << y << endl;     // x = 3 y = 2
  cout << "xx = " << xx << " yy = " << yy << endl; // xx = 2 yy = 1
  return 0;
}
```

### 内联展开能够从什么地方提高效率，从函数传参考虑

（减少参数拷贝操作，被纠正是减少了栈调用）

内联展开可以提高程序的执行效率，主要体现在以下几个方面：（from gpt）
1. **减少函数调用开销：** 函数调用涉及到压栈、传参、弹栈等操作，这些开销在函数调用频繁或函数体较小的情况下可能成为性能瓶颈。内联展开避免了这些开销，直接在调用点插入函数体，减少了函数调用的开销。
2. **减少跳转和缓存不命中：** 函数调用涉及到跳转指令，而跳转指令可能引发预测错误，导致流水线中的指令被清空，增加了流水线的停顿时间。内联展开减少了跳转的次数，有助于减小指令预测错误的概率。此外，内联展开也有助于提高代码的局部性，减少了函数体的代码大小，有助于提高指令缓存（instruction cache）的命中率。
3. **优化循环：** 内联展开对循环优化很有效。在循环体内嵌套一些短小的函数，通过内联展开可以减少循环控制开销，提高循环的执行效率。

## 07 宏定义和 typedef 的区别

宏定义（#define）和 typedef 都是 C++ 语言中用于定义别名的方法，但它们有一些关键区别：

1. 语法和实现机制：
- 1）宏定义 `#define` 是在编译期间将宏进行展开，替换其中的文本，但是不会涉及类型检查。
- 2）而 typedef 是编译期间处理的，有更加严格的类型检查。

2. 作用域限制：
- 1）宏定义之后，宏可以使用在任何地方，可以用来定义变量、表达式和简单的代码片段。
- 2）typedef 遵从 C++ 的作用域规则，受到命名空间、类等结构的作用域限制。typedef 通常用于定义复杂类型的别名，使代码更易读和易于维护，如：

```cpp
typedef std::map<std::string, std::vector<int>> StringToIntVectorMap;
```

3. 模板支持：
- 1）宏定义不支持模板，因此不能用于定义模板类型别名。
- 2）typedef 可以和模板结合使用，但是在 C++11 之后更加推荐使用 using 关键字来代替 typedef。

```cpp
// 使用 typedef 定义模板类型别名
template <typename T>
struct MyContainer {
    typedef std::vector<T> Type;
};

// 使用 using 定义模板类型别名（C++11 及以后）
template <typename T>
struct MyContainer {
    using Type = std::vector<T>;
};
```

相关问题：typedef 和 using 的区别？

## 08 extern 关键字
### C++ 链接属性

在 C++ 中，链接属性是指程序在编译、链接和执行阶段如何处理符号（变量、函数、类等) 的可见性和重复定义。 C++ 语言规定有以下链接属性：

1. **外部链接**（External Linkage）：外部链接的符号可以在不同的源文件之间共享，并且在整个程序执行期间可见。全局变量和函数都具有外部链接。
2. **内部链接**（Internal Linkage）：内部链接的符号只能在当前源文件内部使用，不能被其他源文件访问。用 `static` 修饰的全局变量和函数具有内部链接。
3. **无链接**（No Linkage）：无链接的符号只能在当前代码块（函数或代码块）内部使用，不能被其他函数或代码块访问。用 `const` 或 `constexpr` 修饰的常量具有无链接属性（ 通常情况下编译器是不会为 const 对象分配内存，也就无法链接）。
4. **外部 C 链接**（External C Linkage）：外部 C 链接的符号与外部链接类似，可以在不同的源文件之间共享，并且在整个程序执行期间可见。它们具有 C 语言的名称和调用约定，可以与 C 语言编写的代码进行交互。在 C++ 中，可以用 `extern "C"` 关键字来指定外部 C 链接，从而使用一些 C 的静态库。

### extern 作用

1. **声明变量但不定义**：extern 关键字它只是声明了这个变量或者函数，但是没有定义，这样编译器在链接的时候会在其他的源文件当中查找定义。这样可以使得**不同的源文件共享相同的变量或者函数**。
2. **const 全局变量的外部链接**：全局常量默认是内部链接的，如果想在文件之间传递全局常量需要在声明了定义的时候指明 extern。
3. **编译链接过程的具体原理**：
- 1）在**编译期**，`extern` 用于告诉编译器某个变量或函数的定义在其他源文件中，编译器会为它生成一个符号表项，并在当前源文件中建立一个对该符号的引用。这个引用是一个**未定义的符号**，编译器在后续的链接过程中会在其他源文件中查找这个符号的定义。
- 2）在**链接期**，链接器将多个目标文件合并成一个可执行文件，并且在当前源文件中声明的符号，会在其它源文件中找到对应的定义，并将它们链接起来。

注：如果有一个大项目，其中很多文件需要访问 `test.cpp` 文件当中的变量 i，这样的话需要在每个文件前面加上 `extern int i;` 声明，这就导致书写复杂，维护也不方便。此时推荐将**extern 声明语句放在头文件当中使用**，这样其他文件只需要包含这个头文件即可，便于维护。
### extern "C" 作用

- extern "C" 是 C++ 提供的关键字，可以让 C++ 来调用 C 语言当中的变量或函数。
- 如果不使用 extern "C" 的话，由于 C 和 C++ 在编译链接的时候使用的命名规则不一样，这就会导致 C++ 无法调用 C 语言的函数或变量，在链接的时候会找不到符号。

下面是代码示例：

```cpp
// C 语言代码
#include <stdio.h>

void print_message(const char* message) {
    printf("%s\n", message);
}

// C++ 代码
extern "C" {
    // 声明 C 语言函数
    void print_message(const char* message);
}

int main() {
    // 调用 C 语言函数
    print_message("Hello, world!");
    return 0;
}
```

这篇文章更加的详细：[C/C++中的 extern 和extern“C“关键字的理解和使用（对比两者的异同）_c extern c-CSDN博客](https://blog.csdn.net/m0_46606290/article/details/119973574)

#### 重载是如何实现的？

补充——C++ 的命名规则：
- 对于 C++ 语言，由于**需要支持重载**，所以一个函数的链接名（Linkage Name）是由函数的名称、参数类型和返回值类型等信息组成的，**用于在编译和链接时唯一标识该函数**。
- 函数的链接名的生成规则在不同的编译器和操作系统上可能有所不同，一般是由编译器自动处理，不需要手动指定，这个规则常常叫做 **Name Mangling**。
- 不同编译器的命名规则不一样：
	- **Microsoft Visual C++ 编译器（Windows）**：函数的名称会被编译器修改为一个以 "\_" 开头的名称，并加上参数类型和返回值类型等信息，以避免链接冲突。例如，函数 `int add(int a, int b)` 的链接名可能是 `_add_int_int`。
	- **GCC 编译器（Linux）**：也会加上参数类型和返回值类型等信息。例如，函数 `int add(int a, int b)` 的链接名可能是 `_Z3addii`。
	- **Clang 编译器（MacOS）**：函数的链接名的生成规则与 GCC 编译器类似，但稍有不同。例如，函数 `int add(int a, int b)` 的链接名可能是 `_Z3addii`。
- 而 C 语言是不支持重载的，和上面的命名规则也不一样，所以需要使用 `extern "C"` 将 C++ 编译器的命名规则转换为 C 语言的命名规则，从而使得 C++ 代码可以调用 C 语言的函数或变量

相关问题：编译器如何实现重载？（即通过上面的命名规则）

## 09 4 种强制类型转换
### static_cast

- 用法：`static_cast<type>(expression)`
- 和 C 语言的强制类型转换基本是等价的。
- 应用场景：
	- 1）**基本类型的转换**：如 int 转为 double，`double b = static_cast<double>(a);`
	- 2）**指针类型之间的转换**：将一个指针类型转为另外一个指针类型，尤其是在类层次结构中从基类指针转换为派生类指针。但是这种转换不执行运行时类型检查，可能不安全，要自己保证指针确实可以互相转换。
	- 3）**引用类型之间的转换**：类似于指针类型之间的转换，可以将一个引用类型转换为另一个引用类型。在这种情况下，也应注意安全性。
	- 4）**将一个左值转换为一个亡值**：std::move的实现原理，`static_cast<T&&>(t)`。
- static_cast 在编译时执行类型转换，在进行指针或引用类型转换时，需要自己保证合法性。

### dynamic_cast

- 用法：`dynamic_cast<type>(expression)`
- 主要用于父子类层次之间的安全类型转换。它是**运行时执行类型检查**，相比于 static_cast 更加的安全。

应用场景：
1. **向下类型转换**：基类指针/引用转为派生类指针/引用，dynamic_cast 可以保证兼容性，转换失败的时候返回空指针或抛出异常（引用类型）；

```cpp
class Base { virtual void dummy() {} };
class Derived : public Base { int a; };

Base* base_ptr = new Derived();
// 将基类指针base_ptr转换为派生类指针derived_ptr，如果类型兼容，则成功
Derived* derived_ptr = dynamic_cast<Derived*>(base_ptr); 
```

2. **多态类型检查**：处理多态对象的时候，可以用来确定对象的实际类型

```cpp
class Animal { public: virtual ~Animal() {} };
class Dog : public Animal { public: void bark() { /* ... */ } };
class Cat : public Animal { public: void meow() { /* ... */ } };

Animal* animal_ptr = /* ... */;

// 尝试将Animal指针转换为Dog指针
Dog* dog_ptr = dynamic_cast<Dog*>(animal_ptr);
if (dog_ptr) {
    dog_ptr->bark();
}

// 尝试将Animal指针转换为Cat指针
Cat* cat_ptr = dynamic_cast<Cat*>(animal_ptr);
if (cat_ptr) {
    cat_ptr->meow();
}
```

注：dynamic_cast 只有在基类存在虚函数 (虚函数表) 的情况下才有可能将基类指针转化为子类

**dynamic_cast 工作原理：**
1. 首先，`dynamic_cast` 通过查询对象的 vptr 来获取其 RTTI（这也是为什么 dynamic_cast 要求对象有虚函数）
2. 然后，`dynamic_cast` 比较请求的目标类型与从 RTTI 获得的实际类型。如果目标类型是实际类型或其基类，则转换成功。
3. 如果目标类型是派生类，`dynamic_cast` 会检查类层次结构，以确定转换是否合法。如果在类层次结构中找到了目标类型，则转换成功；否则，转换失败。
4. 当转换成功时，`dynamic_cast` 返回转换后的指针或引用。
5. 如果转换失败，对于指针类型，`dynamic_cast` 返回空指针；对于引用类型，它会抛出一个 `std::bad_cast` 异常。

- dynamic_cast 的效率问题
- 有没有其他方法判断是父类还是子类的对象

相关问题：说一下 dynamic_cast，它是如何实现动态类型检查的？
### const_cast

- 用法：`const_cast <new_type> (expression)`，new_type 必须是一个指针、引用或者指向对象类型成员的指针。
- 应用场景：

1. **修改 const 对象**：当需要修改 const 对象的时候，可以使用 const_cast 来删除 const 属性

```cpp
const int a = 42;
int* mutable_ptr = const_cast<int*>(&a); // 删除const属性，使得可以修改a的值
*mutable_ptr = 43; // 修改a的值
```

2. const 对象调用非 const 成员函数：可以通过 const_cast 删除对象的 const 属性

```cpp
class MyClass {
public:
    void non_const_function() { /* ... */ }
};

const MyClass my_const_obj;
MyClass* mutable_obj_ptr = const_cast<MyClass*>(&my_const_obj); // 删除const属性，使得可以调用非const成员函数
mutable_obj_ptr->non_const_function(); // 调用非const成员函数
```

### reinterpret_cast

用法同其他，reinterpret_cast 用于不同类型之间进行低级别的转换，它仅仅是重新解释底层比特（也就是对指针所指针的那片比特位换个类型做解释），而不进行任何类型检查。

比如将 int 指针转为一个 char 指针：

```cpp
int a = 42;
int *p = &a;
char *cp = reinterpret_cast<char*>(p);
```

const_cast 和 reinterpret_cast 都不是安全的，需要谨慎使用。

## 10 struct 和 class 的区别

C++ 当中为了兼容 C 语言保留了关键字 struct，但是语义上进行了扩充。在 C 语言中，struct 只能有成员变量，不能包含成员函数，但是在 C++ 当中 struct 和 class 一样，成员函数和成员变量都可以有。但是它们之间有一些区别：

- class 中类中的成员默认都是 **private** 属性的。而在 struct 中结构体中的成员默认都是 **public** 属性的。
- class 继承默认是 private 继承，而 struct 继承默认是 public 继承。
- class 可以用于定义模板参数，struct 不能用于定义模板参数。

一般来说，使用 struct 来定义一些 POD 数据类型，POD(Plain old data) 类型意味着可以使用 memcpy() 这种 C 语言的函数来进行操作，也就说它的内存布局是可以通过二进制直接拷贝的。但是 class 一般用于非 POD 类型，用在面向对象编程上。

## 11 static 关键字

static 关键字可以用来修饰全局变量、局部变量、函数、类成员变量和类成员函数。

### 修饰全局变量

static 修饰全局变量可以将变量的作用域**限定在当前文件中，使得其他文件无法访问该变量**。 同时，static 修饰的全局变量在程序启动时被初始化（可以简单理解为在执行 main 函数之前，会执行一个全局的初始化函数，在那里会执行全局变量的初始化），生命周期和程序一样长。

```cpp
// a.cpp 文件
static int a = 10;  // static 修饰全局变量
int main() {
    a++;  // 合法，可以在当前文件中访问 a
    return 0;
}

// b.cpp 文件
extern int a;  // 声明 a
void foo() {
    a++;  // 非法，会报链接错误，其他文件无法访问 a
}
```

### 修饰局部变量

static 修饰局部变量可以使得变量在函数调用结束后不会被销毁，而是一直存在于内存中，下次调用该函数时可以继续使用。同时，由于 static 修饰的局部变量的作用域仅限于函数内部，所以其他函数无法访问该变量。

```cpp
void foo() {
    static int count = 0;  // static 修饰局部变量
    count++;
    cout << count << endl;
}

int main() {
    foo();  // 输出 1
    foo();  // 输出 2
    foo();  // 输出 3
    return 0;
}
```

#### 补充：static 局部变量和普通变量有什么区别？

1. **生命周期：**
	- **普通局部变量：** 普通局部变量的生命周期仅在其声明的代码块内，当程序执行离开该代码块时，普通局部变量就会被销毁。
	- **`static` 局部变量：** `static` 局部变量的生命周期贯穿整个程序运行周期。它在程序首次执行到该变量声明的代码行时初始化，只在程序结束时被销毁。
1. **存储位置：**
	- **普通局部变量：** 普通局部变量通常存储在栈上，每次函数调用时都会分配和释放内存。
	- **`static` 局部变量：** `static` 局部变量存储在全局数据区，而不是栈上。这使得它在函数调用之间保持其值。
1. **初始化：**
    - **普通局部变量：** 普通局部变量在每次函数调用时都会重新初始化，即使上一次调用结束时给它赋过值。
    - **`static` 局部变量：** `static` 局部变量只在第一次调用函数时初始化，之后的调用会继续使用上一次调用结束时的值。

### 修饰函数

static 修饰函数，可以将函数的作用域限定在当前文件当中，其他文件无法使用该函数。因为 static 修饰的函数只能在当前文件中被调用，所以可以用来**避免命名冲突和代码重复定义**。

```cpp
// a.cpp 文件
static void foo() {  // static 修饰函数
    cout << "Hello, world!" << endl;
}

int main() {
    foo();  // 合法，可以在当前文件中调用 foo 函数
    return 0;
}

// b.cpp 文件
extern void foo(); // 声明 foo
void bar() {
    foo();  // 非法，会报链接错误，找不到 foo 函数，其他文件无法调用 foo 函数
}
```

#### 补充：两个编译单元相同名字的 static 函数会报错吗？

答案是不会报错，因为 static 函数的链接属性是内部属性，在各个编译单元里是独立的，不会发生冲突。

### 修饰类成员变量和函数

static 修饰类成员变量和函数，可以让它们在所有的类对象中共享，

```cpp
class MyClass {
public:
    static int count;  // static 修饰类成员变量
    static void foo() {  // static 修饰类成员函数
        cout << count << endl;
    }
};

// 访问：
MyClass::count;
MyClass::foo();
```
