## 01 并发和并行的概念

**1. 并发（Concurrency）：**
- 并发指的是在同一时间段内处理多个任务，这些任务可能在彼此之间交替执行。
- 在并发模型中，一个处理器（或核心）**交替执行多个任务的片段**，每个任务都在不同的时间点上执行，但它们的执行时间可能重叠。

**2. 并行（Parallelism）：**
- 并行指的是在同一时刻同时执行多个任务，每个任务都在独立的处理器（核心）上运行。
- 并行是多个处理器同时的处理多个任务。

**并发强调的是多个任务在同一时间段内交替的运行，并行强调的是多个任务在同一时刻实际上同时执行。**

![](pics/Pasted%20image%2020240105105451.png)

## 02 互斥和同步的概念

多线程在竞争操作共享变量的时候，在执行的过程当中可能会发生上下文切换，从而可能会导致最终结果和预期的不一致。由于多线程执行操作共享变量的这段代码可能会导致竞争状态，因此我们将此段代码称为**临界区（critical section），它是访问共享资源的代码片段，一定不能给多线程同时执行。**

**互斥**：就是需要保证一个线程在临界区执行代码的时候，其他的线程需要阻止进入临界区，也就是一次最多只有一个线程执行这段代码。

**同步**：多线程当中，线程不一定按照顺序执行的，它们之间可能需要相互协作，所以同步就是**并发进程/线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程/线程同步。**

## 03 锁
### 常用的锁有哪些？

1. **自旋锁（Spin Lock）**：如果进线程无法取得锁，**进线程不会立刻放弃 CPU 时间片，而是一直循环尝试获取锁，直到获取为止**。如果别的线程长时期占有锁，那么自旋就是在浪费 CPU 做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。
2. **互斥锁（Mutex）**：一次只能一个线程拥有互斥锁，其他线程只有等待。互斥锁是在抢锁失败的情况下**主动放弃 CPU 进入睡眠状态直到锁的状态改变时再唤醒**，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。
3. **读写锁（Read-Write Lock）**：区分读取操作和写入操作，允许多个线程同时读取共享资源，但在写入时只允许一个线程访问。

其他用于同步的一些手段：
- **条件变量（Condition Variable）**：允许线程阻塞和等待另一个线程发送信号，常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量**唤醒一个或多个正被此条件变量阻塞的线程**。
- **信号量（Semaphore）**：用于控制对共享资源的访问数量，而不仅仅是一个。通常**信号量表示资源的数量**，对应的变量是一个整型（`sem`）变量。还有**两个原子操作的系统调用函数来控制信号量的**：
	- **P 操作**：将 `sem` 减 `1`，相减后，如果 `sem < 0`，则进程/线程进入阻塞等待，否则继续，表明 P 操作可能会阻塞；
	- **V 操作**：将 `sem` 加 `1`，相加后，如果 `sem <= 0`，唤醒一个等待中的进程/线程，表明 V 操作不会阻塞；

### 自旋锁是如何实现的？

自旋锁是通过 CPU 体系结构提供的特殊**原子操作**实现的，所谓原子操作就是**要么全部执行，要么都不执行，不会出现执行一半的中间状态**。

常用的原子操作是**测试并设置指令**（test-and-set instruction），也叫作**原子交换**（atomic exchange）：

下面是这个指令的 C 语言伪代码：

```c
int TestAndSet(int *old_ptr, int new) {
	int old = *old_ptr; // fetch old value at old_ptr
	*old_ptr = new; // store 'new' into old_ptr
	return old; // return the old value
}
```

这条指令返回 old_ptr 的旧值，并且将其更新为新值，上面的代码是**原子地执行**，可以利用它来实现一个自旋锁：

```c
typedef struct lock_t {
	int flag;
} lock_t;

void init(lock_t *lock) {
	// 0 表示这个锁可以获得，1表示这个锁被别的线程持有了
	lock->flag = 0;
}

void lock(lock_t *lock) {
	while (TestAndSet(&lock->flag, 1) == 1)
		; // spin-wait (do nothing)
}

void unlock(lock_t *lock) {
	lock->flag = 0;
}
```

- 当某一个线程已经持有锁（即 flag 为 1）；
- 本线程调用 lock()，然后调用 TestAndSet(flag, 1)，这一次返回 1；
- 只要另一个线程一直持有锁，TestAndSet() 会重复返回 1，本线程会一直自旋；
- 当 flag 终于被改为 0，本线程会调用 TestAndSet()，返回 0 并且原子地设置为 1，从而获得锁，进入临界区。

另外一个原子操作有：**比较并交换指令**（SPARC 系统中是 compare-and-swap，x86 系统是 compare-and-exchange）。

```c
int CompareAndSwap(int *ptr, int expected, int new) {
	int actual = *ptr;
	if (actual == expected)
		*ptr = new;
	return actual;
}
```

比较并交换的基本思路是检测 ptr 指向的值是否和 expected 相等；如果是，更新 ptr 所  
指的值为新值。否则，什么也不做。

这条指令可以替换上面的 **测试并设置** 指令，检查标志是否为 0，如果是，原子地交换为 1，从而获得锁。锁被持有时，竞争锁的线程会自旋。

```c
void lock(lock_t *lock) {
	while (CompareAndSwap(&lock->flag, 0, 1) == 1)
		 ; // spin
}
```

### 信号量是如何实现的？

信号量的实现主要是 PV 操作的实现：

![](pics/Pasted%20image%2020240108112155.png)
### 一些对比

**自旋锁和互斥锁的区别**：它们最主要的区别是自旋锁在没有获得锁的时候会一直自旋，不会让出 CPU，而互斥锁抢占锁失败的时候，会进入睡眠状态，等待操作系统调度，直到可以获得锁。

**互斥锁和信号量的区别**：它们最主要的区别是互斥锁是用来保护临界区，保证同一时刻只有一个线程执行临界区的代码，而信号量主要用于对一组资源的访问，以及限制同时访问临界区的线程数量。此外，**信号量不仅可以实现临界区的互斥访问控制，还可以线程间的事件同步。**

互斥锁为什么要先自旋再阻塞？
- 因为对于互斥锁发生竞争的情况时，竞争的时间可能是短暂的，即锁的持有者很快会释放锁，这个时候使用先自旋一段时间的话，会更加的高效，因为自旋不会让线程频繁的在用户态和内核态之间相互切换。

## 04 死锁
### 死锁的概念

在多线程编程中，为了防止多线程竞争共享资源而导致数据错乱，都会在操作共享资源之前加上互斥锁，只有成功获得到锁的线程，才能操作共享资源，获取不到锁的线程就只能等待，直到锁被释放。

当两个线程为了保护两个不同的共享资源而使用了两个互斥锁，那么这两个互斥锁应用不当的时候，可能会造成**两个线程都在等待对方释放锁**，在没有外力的作用下，这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了**死锁**。

### 死锁发生的条件

死锁只有**同时满足**以下四个条件才会发生：
1. **互斥条件**：指的是**多个线程不能同时使用同一个资源**。比如 A 线程获取一个资源，此时 B 线程无法获取这个资源，只能等待。
2. **请求和保持条件**：当线程 A 已经持有了资源 1，又想申请资源 2，而资源 2 已经被线程 B 持有了，所以线程 A 就会处于等待状态，但是**线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1**。
3. **非抢占条件**：资源不能被抢占，只能由占有它的线程显式释放。如果一个线程持有了某个资源，其他线程无法强制抢占这个资源，只能等待占有资源的线程主动释放。
4. **循环等待条件**：存在两个或多个线程形成环路，即每个线程都在等待下一个线程所持有的资源。

### 如何确定哪个线程死锁了？  

首先如果怀疑一个程序发生了死锁，可以通过 top 命令来查看这个程序的 CPU 和内存占用情况，如果发生死锁的话，这个程序会处于阻塞的状态，CPU 和内存占用率很低。

接着可以 ps 命令获得这个进程的进程号，`ps aux | grep a.out` 来查看 a.out 的进程号。

然后 gdb attach 进程号，就可以进入 gdb 的情况了，gdb 当中 `info threads` 可以查看当前线程的情况， `thread` 命令可以切换线程，，使用 `backtrace` 或 `bt` 命令查看线程的堆栈信息，以了解线程的当前执行情况，然后根据相应线程的执行情况来判断是否发生死锁。

### 如何解决死锁

解决死锁一般是打破死锁发生的 4 个必要条件：

- 最常用的是**使用资源有序分配法，来破环循环等待条件**。即让每个线程获取资源的时候，加锁的顺序都是一致的，比如 A 线程获取资源 1 和 2，对于 B 线程来说也是通过先获取资源 1 再获取资源 2 的顺序，这样可以避免循环等待条件。
- 采用一些**死锁检测算法**，比如说构建等待图，如果发现发生了死锁，就需要采取恢复措施，释放资源或终止某些线程。
- 加入**超时机制**，当某个线程持有并等待资源的时候，如果超过一定时间没有还是没获得资源，就将这个线程的持有的锁主动释放。

