## 01 进程基础知识
### 什么是进程？

我们编写的代码只是一个存储在硬盘的静态文件，通过编译后就会生成二进制可执行文件，当我们运行这个可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，那么这个**运行中的程序，就被称为「进程」（Process）**。

### 进程的状态有哪些？

1. **创建状态**：进程刚创建出来，还没完成初始化，不能被调度。该状态初始化之后进入就绪状态；
2. **就绪状态**：该状态的进程可以被调度执行，但是调度器还没选择这个进程，因为 CPU 一般远远小于进程数量，只有部分进程可以在 CPU 上运行；
3. **运行状态**：该状态的进程正在 CPU 上执行，运行一段时间后，调度器可以将它中断，并重新返回调度队列，它就回到就绪状态。进程运行结束会进入终止状态。如果需要等待某些事件（比如 IO），它可以放弃运行进入阻塞状态。
4. **阻塞状态**：该状态进程需要等待外部的事件完成（比如某个 IO 请求），暂时无法被调度。外部事件完成后会进入就绪状态。
5. **终止状态**：该进程已经完成了执行，不会被调度。

![](pics/Pasted%20image%2020240103103152.png)

### 进程在操作系统中是如何表示的？

在操作系统中，进程是用进程控制块（PCB）数据结构来描述进程的。PCB 是进程的唯一标识，如果进程结束了，对应的 PCB 也会被释放，PCB 主要包括以下内容：
- **进程描述信息**：进程标识符 PID、用户标识符（进程归属于哪一个用户）；
- **进程控制和管理信息**：进程的状态、优先级等；
- **资源分配**：虚拟内存地址空间相关的信息，打开的文件，使用的 IO 设备等；
- **CPU 相关信息**：CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。

### 什么是上下文切换？

进程是共享 CPU 资源的，不同的进程都是可以在 CPU 上执行，**一个进程切换到另外一个进程，就称之为进程的上下文切换**。需要理解以下几种上下文：
- **CPU 上下文**：对于 CPU 来说有栈指针寄存器、存放当前指令位置的程序计数器（PC），以及其他相应的寄存器等等。这些 CPU 依赖的环境就称之为上下文。CPU 发送上下文切换的时候，就是将上一个任务的 CPU 寄存器和程序计数器等保存起来，然后加载新的任务的上下文，再跳转到新的 PC 指向的位置，运行新的任务。
- **进程上下文**：进程是由内核调度和管理的，所以进程的切换只能发生在内核态。所以**进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。**
- 其实上面的八股内容不太全面，因为对于一个用户进程来说，如果想切换到另外一个用户进程，它需要做的事情是先从用户态切换到内核态，这个时候发生中断上下文切换，然后再从内核进程切换到另外一个内核进程，新的内核进程通过中断方式切换到用户进程开始执行。

哪些场景会导致进程发生上下文切换？
- 为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行；
- 进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行；
- 当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度；
- 当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行；
- 发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序；

## 02 线程基础知识
### 线程是什么？

进程的问题在于 1）创建一个进程的开销很大，需要创建完整的地址空间、载入数据和代码段、初始化堆等；2）进程因为有独立的虚拟地址空间，所以进程间通信和同步比较麻烦。所以提出线程的概念，**线程是进程当中的可独立执行的单元，它们共享进程的地址空间，但是又有各自运行时的状态**（即上下文），它取代了进程，成为操作系统调度和管理程序的最小单元。

### 线程优缺点

- 线程的优点：
	- 一个进程中可以同时存在多个线程；
	- 各个线程之间可以并发执行；
	- 各个线程之间可以共享地址空间和文件等资源；
- 线程的缺点：
	- 当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（这里是针对 C/C++ 语言，Java 语言中的线程奔溃不会造成进程崩溃，具体分析原因可以看这篇：[线程崩溃了，进程也会崩溃吗？ (opens new window)](https://xiaolincoding.com/os/4_process/thread_crash.html)）。

举个例子，对于游戏的用户设计，则不应该使用多线程的方式，否则一个用户挂了，会影响其他同个进程的线程。

### 线程和进程的区别

- 进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；
- 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；
- 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；
- 线程能减少并发执行的时间和空间开销；

线程相比进程能减少开销，体现在：

- 线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；
- 线程的终止时间比进程快，因为线程释放的资源相比进程少很多；
- 同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；
- 由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；

**进程线程的使用场景？** #TODO

### 线程上下文切换

线程与进程最大的区别在于：**线程是调度的基本单位，而进程则是资源拥有的基本单位**。所以对于操作系统的任务调度来说，实际调度对象时线程，当进程只有一个线程的时候，可以认为进程对于线程，当进程有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源，这些上下文切换的时候不需要更改。但是线程有自己的私有数据，比如栈和寄存器，这些上下文切换是需要保存的。

所以对于线程上下文切换来说分为两种情况：
- 如果是相同进程的线程切换，只需要切换线程私有数据即可，因为虚拟内存等资源是共享的，是不需要切换的；
- 如果是不同进程的线程切换，那和进程的上下文切换是一样的。

### 几种线程的实现方式

- **1. 用户态线程**：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；**用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户态线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。**
	- 优点：1）每个进程需要有私有的线程控制块（TCB）来维护线程信息，用户线程的 TCB 是用户态线程库维护的，可以用于对于不支持线程的操作系统；2）**线程的切换不需要经过内核态和用户态的转换，速度很快**；
	- 缺点：1）操作系统不进行调度用户态线程，一旦某个线程阻塞，进程的所有用户态线程都会阻塞；2）线程运行后，除非主动交出 CPU 使用权，否则其他线程无法打断运行中的线程；3）时间片是分配给进程的，与其他进程相比，多线程执行下，每个线程分配到的时间片比较少；
- **2. 内核态线程**：内核态线程是由操作系统管理的，线程对应的 TCB 自然是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责。
	- 优点：1）一个进程当中的某个内核态线程因为系统调用阻塞，并不会影响其他的线程；2）调度的时间片是分配给线程的，多线程的进程获得更多的 CPU 运行时间；
	- 缺点：1）在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息，如 PCB 和 TCB；2）线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大；
- **3. 轻量级进程（_Light-weight process，LWP_）**：是内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持，而且 LWP 是由内核管理并像普通进程一样被调度。
- 在大多数系统中，**LWP 与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息**。一般来说，一个进程代表程序的一个实例，而 LWP 代表程序的执行线程，因为一个执行线程不像进程那样需要那么多状态信息，所以 LWP 也不带有这样的信息。

为了实现用户态线程和内核态线程的协作，操作系统会建立两种线程的关系，称为多线程模型，有以下三种：
- 1）多对一模型：多个用户线程对应同一个内核线程；
- 2）一对一模型：一个用户线程对应一个内核线程；
- 3）多对多模型：多个用户线程对应到多个内核线程；

### 线程控制块

和进程类型，线程也有自己的线程控制块（TCB），用于保存自身相关的信息。主流的一对一模型当中，内核态线程和用户态线程都有自己的 TCB。
- 内核态线程的 TCB 和进程的 PCB 类似，会存储线程的运行状态、内存映射、标识符等信息；
- 用户态线程的 TCB 由线程库决定，例如 Linux 当中的 pthread 线程库，pthread 结构体就是用户态的 TCB。用户态的 TCB 可以认为是内核态线程 TCB 的扩展，可以存放更多用户线程的信息，最重要的是**线程本地存储（TLS）**：
	- 多线程当中，TLS 可以实现一个名字，多份拷贝的全局变量。即不同线程在使用该变量的时候，代码层面看起来是同一个变量，但是实际访问的是不同变量的拷贝，于是可以方便的实现线程内部的全局变量。例如 `__thread int count;` 修改 count 的时候不会对其他线程的 count 产生影响。

## 03 进程间通信

进程间通信方式主要有以下几种：
- 1. **匿名管道**：最常见的 shell 命令当中的 `|`，匿名管道是特殊的文件，只存在于内存，通信的数据是**无格式的流并且大小受限**，通信是单向的，如果想要双向的话需要创建两个管道；
	- 使用的场景是：**只能用于父子进程之间的通信**，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。
- 2. **命名管道**：命名管道通过 `mkfifo` 命令创建一个设备文件，可以用在任意的进程之间进行通信。两种管道的数据都是写到内核当中，另外一个进程也是从内核读取数据，通信的数据都是**先进先出**，不支持 lseek 等定位文件操作。
- 3. **消息队列**：**消息队列是保存在内核中的消息链表**，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。
	- 消息队列主要用于进程之间需要频繁的交换数据；
	- 消息队列本身**通信并不及时，不能传输太大数据，通信的过程中还存在内核态和用户态数据拷贝的开销。**
- 4. **共享内存**：将一块虚拟内存映射到相同的物理内存上，这样一个进程拷贝的数据，另外一个进程也可以看见，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有**最快**的进程间通信方式之名。但是**多进程竞争同个共享资源会造成数据的错乱。**
- 5. **信号量**：主要用来保护共享的资源，确保任何时刻只能有一个进程访问共享资源，即互斥访问。**信号量不仅可以实现访问的互斥性，还可以实现进程间的同步**，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 **P 操作和 V 操作**。
- 6. **信号**：唯一的**异步通信机制**，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，**进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号**。有两个信号是应用进程无法捕捉和忽略的，即 `SIGKILL` 和 `SIGSTOP`，这是为了方便我们能在任何时候结束或停止某个进程。
- 7. **Socket**：主要用于不同主机进程之间的通信，也可以用于本地主机进程间通信，根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。

线程间通信方式？

- 同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量。所以对于线程间关注的不是通信方式，而是关注**多线程竞争共享资源的问题**，信号量也同样可以在线程间实现互斥与同步：
- 互斥：可保证任意时刻只有一个线程访问共享资源；
- 同步：可保证线程 A 应在线程 B 之前执行；

#TODO 具体介绍 Linux 创建一个管道函数，参数设置，共享内存怎么做

## 04 进程调度
### 什么是进程调度？

调度：一个系统会同时处理多个请求，但是其资源是有限的，调度就是用来协调每个请求对资源的使用的方法。
- 任务调度 (或叫 CPU 调度)：负责调度可运行的进程对 CPU 的使用；
- I/O 调度：负责对应该以何种顺序向存储设备发起 I/O 请求进行调度；
- 内存调度：通过换页机制对哪部分物理页的内容可以留在内存中进行调度。

### 什么时候发生进程调度？

进程的生命周期当中，从一个状态切换到另外一个状态，就会发生一次调度，例如：
- **从就绪态 -> 运行态**：当进程被创建时，会进入到就绪队列，操作系统会从就绪队列选择一个进程运行；
- **从运行态 -> 阻塞态**：当进程发生 I/O 事件而阻塞时，操作系统必须选择另外一个进程运行；
- **从运行态 -> 结束态**：当进程退出结束后，操作系统得从就绪队列选择另外一个进程运行；

### 调度的基本原则

调度有以下几个基本原则，这些也是用来评价一个进程调度算法优劣的指标：
- **CPU 利用率**：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率；
- **系统吞吐量**：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量；
- **周转时间**：周转时间是任务完成时间减去任务到达系统的时间，一个进程的周转时间越小越好；
- **等待时间**：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意；
- **响应时间**：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。

### 调度算法有哪些？

1. **先来先服务算法（FIFO）**
- 简单归纳就是：那个程序先到，先让哪个程序运行。
- 优点：简单、易于实现；
- 缺点：对于短任务来说，周转时间会比较长，比如前面有一个长任务，会一直等待长任务执行完成才去运行短任务。
2. **最短任务优先（SJF）**
- 简单总结就是：对于同一时间到达的任务，优先运行时间短的任务。
- 优点：平均等待时间较短，适用于短作业时间的情况。
- 缺点：可能导致长作业等待时间过长。可能会出现**饥饿**的情况，即一直有短作业到达时，长作业无法被执行。
3. **优先级调度算法 (Priority Scheduling)：**
- **优点：** 能够根据任务的优先级进行调度，可以根据系统的需求调整优先级。适用于不同类型任务的场景。
- **缺点：** 可能导致低优先级的任务长时间等待，可能出现优先级反转的问题。
4. **时间片轮转（RR）**：
- 基本思想：在一个 **时间片** 内运行一个工作，然后切换到运行队列中的下一个任务，而不是运行一个任务直到结束。它反复执行，直到所有任务完成。
- 优点：简单且公平，每个进程都有相等的机会获得 CPU 时间。
- 缺点：时间片越短，响应时间表现越好，但是，太短会导致上下文切换的开销影响性能。
- RR 算法**周转时间很差**，更一般地说，任何 **公平** 的政策（如 RR），即在小规模的时间内将 CPU 均匀分配到活动进程之间，在周转时间这类指标上表现不佳。
5. **多级反馈队列（Multi-level Feedback Queue，MLFQ）**：
- MLFQ 中有许多独立的队列，每个队列有不同的优先级。任何时刻，一个工作只能存在于一个队列中。**MLFQ 总是优先执行较高优先级的工作**（即在较高级队列中的工作）。
- MLFQ 的优化规则：
	- 规则 1：如果 A 的优先级 > B 的优先级，运行 A（不运行 B）。
	- 规则 2：如果 A 的优先级 = B 的优先级，轮转运行 A 和 B。
	- 规则 3：工作进入系统时，放在最高优先级（最上层队列）。
	- 规则 4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少 CPU），就降低其优先级（移入低一级队列）。
	- 规则 5：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。
- 优点：对于短作业可能在第一级队列当中就运行结束了，对于长作业，第一级队列可能没运行结束，但是会移动到下一级队列等待执行，虽然等待时间长了，但是运行时间也会更长了，所以该算法很好的**兼顾了长短作业，同时有较好的响应时间。**

### 补充：Linux 中的完全公平调度（CFS）

CFS 调度的出发点是：模拟出一种“**公平的、精确的任务多处理 CPU**”。
- 公平：对于 n 个正在运行的进程，当这些任务同时不断地运行时，CPU 会尽可能分配给他们 1/n 的处理时间。**CFS 是一种基于加权公平排队思想的调度算法**。
- 精确：它采用红黑树作为调度的任务队列的数据结构。

CFS 调度的基本思想是：
- 1）使用红黑树，来存放调度的任务队列；
- 2）每个节点代表了一个调度的任务，节点的 key 为虚拟时间（vruntime），vruntime 是由任务的运行时间计算而来的；
- 3）vruntime 越小，在红黑树中对应的节点越往左；
- 4）CFS 调度器（Scheduler）**每次挑选最左边的节点作为下一个要运行的任务**。其中最左边的节点是有一个指针进行维护的，即红黑树插入删除的时候会维护这个最左边的节点指针，所以对于 CFS 调度器来说，查找的时间复杂度为 O(1)

vruntime 如何计算得到的？

**vruntime += 实际运行时间 * 1024 / 进程权重**，其中进程的权重是根据进程的 nice 值得到的，nice 值可以理解为是我们事先为任务分配的优先级。

对于新的进程来说，它的 vruntime 是否为 0？

- 假如新进程的 vruntime 初值为 0 的话，比老进程的值小很多，那么它在相当长的时间内都会保持抢占 CPU 的优势，老进程就要饿死了，这显然是不公平的。所以 CFS 是这样做的：每个 CPU 的运行队列 cfs_rq 都维护一个 min_vruntime 字段，**记录该运行队列中所有进程的 vruntime 最小值**，新进程的初始 vruntime 值就以它所在运行队列的 min_vruntime 为基础来设置，与老进程保持在合理的差距范围内。

**CFS 的唤醒抢占特性：**
- 休眠进程在唤醒时会获得 vruntime 的补偿，它在醒来的时候有能力抢占 CPU 是大概率事件，这也是 CFS 调度算法的本意，即保证交互式进程的响应速度，因为交互式进程等待用户输入会频繁休眠。

参考：[操作系统调度算法3——CFS，完全公平调度器 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/372441187)

### 调度相关的概念补充

时间片：表示进程被抢占前能持续运行的时间。时间片过长会导致交互的响应时间很差，时间片太短会增大进程切换带来的开销。
