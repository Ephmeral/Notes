
## 虚拟内存
### 为什么需要虚拟内存？

对于操作系统来说，需要运行不同的程序，而程序需要加载到物理内存当中才能够运行，操作系统如何让它们共同使用物理内存资源？有两种初步的思路：

- 1. **允许每个进程访问所有的内存**：这样当 A 进程需要切换的时候，会将内存保存到磁盘当中，然后再将 B 进程的内容加载到内存执行。缺点：存储设备的读写相比内存要慢很多，切换程序的时间开销很大；
- 2. **让每个进程独立的使用部分内存**：让每个程序独立使用内存的一部分，数据一直在内存中，程序切换的时候无需操作存储设备；性能相比上个方法要优，但是仍有弊端：
	- 1）无法保证不同程序使用的物理内存相互隔离，程序 A 可能会访问到程序 B 的内存，导致未定义行为发生；
	- 2）无法保证程序使用的地址空间是统一和连续的，增加了程序的编写和编译复杂性；

操作系统究竟是如何让不同的应用程序能够既高效、又安全地、共同使用物理内存资源的？现代操作系统的普遍做法是在应用程序与物理内存之间加入一个新的抽象：**虚拟内存**
- CPU 负责将虚拟地址翻译成物理地址；
- 操作系统负责设置虚拟地址与物理地址之间的映射；
- 每个应用程序只能看见自己虚拟地址空间，保证**程序内存之间隔离性**；
- 每个程序的虚拟地址应该是**统一的、连续的，降低编程复杂性**；

虚拟内存的设计需要满足下面三个目标：
- **高效性**：1）不能在应用程序运行的过程中造成明显的性能开销；2）虚拟内存抽象不应该占用太多的物理内存资源；
- **安全性**：不同程序之间的虚拟内存应该相互隔离，即一个程序只能访问属于自己的物理内存部分；
- **透明性**：应用程序开发者编程的时候无须考虑虚拟内存抽象；

所以概述性回答为什么需要虚拟内存：
- 1）为进程提供了一层抽象，每个进程只能访问自己的虚拟地址，保证了不同进程内存之间的隔离性。
- 2）统一了进程的虚拟地址，降低了编程复杂性，程序员编程的时候无需考虑虚拟内存抽象。

### 物理地址和虚拟地址

**物理地址**：逻辑上可以将物理内存看成一个大数组，每个内存中的内容都可以通过唯一对应的地址进行访问，这个地址就是物理地址。

**虚拟地址**：就是进程当中使用的地址，引入虚拟内存的抽象之后，应用程序使用虚拟地址访问内存中的数据和代码，程序执行过程中，CPU 会将虚拟地址转换为物理地址，通过物理地址来访问物理内存中的数据。

**地址翻译**：将虚拟地址转化为物理地址的过程。地址翻译的过程通常是由 CPU 中的 **内存管理单元**（MMU）来完成的，同时引入 **转址旁路缓存**（TLB）又称 **快表** 来加速地址翻译过程；

![](pics/4-1CPU-translateAddress.jpg)

操作系统是如何管理虚拟地址与物理地址之间的关系？主要有两种方式，分别是**内存分段和内存分页**。
### 内存分段

程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。**不同的段是有不同的属性的，所以就用分段（_Segmentation_）的形式把这些段分离出来。**

在分段机制下，虚拟地址被分为两个部分：
- 1）**段号**，标识着该虚拟地址对应着虚拟地址空间的哪一个段；
- 2）**段内偏移量**，相对于段的起始地址的偏移量。

另外有一个 **段表** ，它存储着虚拟地址空间中的每一个分段信息，包括 **段起始地址**（对应的是物理内存中某一个段的起始地址）和 **段长**。

地址翻译过程如下：
- MMU 根据 **段表基址寄存器** 找到段表在物理内存中对应的起始地址。
- 通过对虚拟地址进行解析，找到**段号**，然后通过段表和段号来定位到具体某一个段的信息（相当于找到了数组起始地址和下标）
- 根据找到的段内的信息（对应的物理地址），加上虚拟地址的段内偏移量，最终得到虚拟地址对应的物理地址。

![](pics/4-2SgementAddressTranslate.png)

所以对于内存分段机制来说，虚拟地址是通过**段表**与物理内存进行映射的。

内存分段机制有两个缺点：
1. **内存碎片问题**：分段机制很任意导致外部碎片，即段与段之间留下碎片空间，但是这段空间不足以再作为虚拟地址映射对应的段。  
	- 例如：6GB 物理内存，目前分为 0~2GB，2~3GB，3~5GB 和 5~6GB，如果第二段和第四段被释放，此时又需要分配一个 2G 的段，这时虽然有 2G 的空间，但是不连续，分配失败。
2. **内存交换的效率低**：因为分段机制很容易出现外部碎片，这个时候需要通过**内存交换**的方式，先将不连续的内存写入磁盘当中，然后再从磁盘按照连续的写回内存。因为需要和磁盘发生内存交换，而磁盘的访问速度比内存慢很多，**如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿，效率低下。**

### 内存分页

内存分页机制通常将物理地址和虚拟地址分为连续的、等长的虚拟页（通常 4KB），操作系统为每个程序分配一个**页表**，页表存放了虚拟地址到物理地址之间的映射关系。

页表本身是存放在物理内存当中的，当进程访问的虚拟地址在页表中查不到时，系统会产生一个**缺页异常**，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。

在分页机制下，虚拟内存也分为两个部分：
- 1）虚拟页号：作为页表的索引
- 2）页内偏移量

页表包含了每个页面所在物理地址的起始地址，有了这个起始地址再加上页内偏移量，就可以得到物理内存地址。

所以分页机制下，对于一个虚拟地址转换为物理地址过程如下：
- 首先 MMU 找到 **页表基址寄存器** 中页表的起始地址；
- 根据虚拟地址的页号，和页表起始地址找到对应的物理页号；
- 由得到的物理页号和虚拟地址的页内偏移量得到最终的物理地址；

![](pics/Pasted%20image%2020240109135342.png)

分页机制是如何解决分段机制「内存外部碎片和内存交换效率低」的问题的？

- 分页机制，**页与页之间是紧密排布的，不会有外部碎片问题**。
- 如果内存不足，操作系统会将其他采用内存页面置换算法，将要替换的页面暂时的写入磁盘，需要的时候再加载到内存中。所以，一次性写入磁盘的页面很少，不会花太多时间，**内存交换的效率就相对比较高。**

分页机制有什么问题？

1. **内部碎片问题**：如果请求的页面大小小于 4KB 的话（比如 2KB），因为分页机制是固定分配 4KB 大小的页，就会导致有 2KB 的内存实际上并没有使用，也就是内部碎片问题。
2. **页表本身占用的空间大小**：32 位环境下，虚拟地址空间为 4G，一个页大小为 4KB($2^{12}$)，则有 $2^{20}$ 个页，每个页需要 4 字节存储（32 位），整个页表大小为 4MB，如果进程很多的话，占用空间会非常大。
3. **地址翻译过程速度也不快**：访问一个数据的时候，首先需要知道页表的起始的物理地址，需要通过页表基址寄存器来找到页表的起始物理地址，然后再根据页表项的内容进行转换得到物理地址，最后从内存中获得数据。**所以对于每个内存引用（取指令、加载或存储），分页机制都需要执行一个额外的内存引用，即先通过读取页表项当中的内容，来获得物理地址**。

上面三个问题如何解决：
- 内部碎片，考虑使用内存池的思路，通过预先分配一定大小的内存块，并在运行时按需分配给程序，减少内部碎片的发生。这里不细说了。
- 页表本身占用问题，采用多级页表，下面解释。
- 分页也可能比较慢，操作系统采用了 TLB，即**地址转换旁路缓冲存储器**，来加速地址翻译过程。

### 多级页表

单页表的时候，32 位环境，页表大小 4KB 的时候，大概需要 $2^{20}$ 个页表项，每个页表占用 4MB 大小，将这些页表项再分页，将页表（一级页表）分为 1024 个页表（二级页表），每个表（二级页表）中包含 1024 个「页表项」，形成**二级分页**。

![](pics/Pasted%20image%2020240109142935.png)

有了二级页表，一级页表就可以覆盖整个 4GB 虚拟地址空间，但**如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表**。这样的话，可以大大节省页表本身占用的空间。

那么为什么不分级的页表就做不到这样节约内存呢？
- 我们从页表的性质来看，保存在内存中的页表承担的职责是将虚拟地址翻译成物理地址。假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了。
- 所以**页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项**（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。

二级页表推广到多级页表可以进一步节省内存空间，64 位一般采用的是四级页表：

![](pics/Pasted%20image%2020240109144354.png)

### TLB

前面提到对于地址翻译过程，需要进行额外的一次内存访问来得到物理地址，然后再通过物理地址进行内存访问。如果是多级页表的话，一次地址翻译可能导致多次物理内存访问。

为了减少访问次数，MMU 引入转址旁路缓存（Translation Lookaside Buffer, TLB），TLB 缓存了虚拟页号到物理页号的映射关系。MMU 会先根据虚拟页号去查找 TLB 的缓存项，找到即可直接返回，无须去查询页表，如果通过 TLB 直接完成地址翻译过程称为 **TLB 命中**，反之为 **TLB 不命中**。

## malloc

### malloc 分配内存的原理

[2万字|30张图带你领略glibc内存管理精髓 (qq.com)](https://mp.weixin.qq.com/s/pdv5MMUQ9ACpeCpyGnxb1Q)
### 1G 的物理内存 malloc 一块 4G 的内存怎么样

简单说结论：
- 对于 32 位系统，地址空间是 4G，而最上面的 1G 是要交给内核的，所以进程最多可以分配的虚拟内存是 3G，如果 malloc 一块 4G 的内存会直接失败。
- 对于 64 位系统，因为进程理论上最大能申请 128 TB 大小的虚拟内存，即使物理内存只有 1GB，申请 4G 内存也是没问题，因为申请的内存是虚拟内存。如果这块虚拟内存被访问了，要看系统有没有 Swap 分区：
	- 如果没有 Swap 分区，因为物理空间不够，进程会被操作系统杀掉，原因是 OOM（内存溢出）；
	- 如果有 Swap 分区，即使物理内存只有 1GB，程序也能正常使用 4GB 的内存，进程可以正常运行；

参考：[4.4 在 4GB 物理内存的机器上，申请 8G 内存会怎么样？](https://xiaolincoding.com/os/3_memory/alloc_mem.html#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F)

---
