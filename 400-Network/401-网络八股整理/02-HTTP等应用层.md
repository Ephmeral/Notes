## HTTP 基础概念

### 1. 什么是 HTTP？
- HTTP 是超文本传输协议，也就是**H**yper**T**ext **T**ransfer **P**rotocol。
- 什么是超文本？
	- 最初**文本**只是简单的字符文字，后来文本的含义拓展到图片、视频、音频等；
	- 而**超文本**，是文字、图片、视频等的混合体，同时能够进行**超链接**的跳转，从一个超文本链接跳转到另一个超文本；
- 什么是传输？
	- 简单理解就是**两台主机之间可以相互进行数据交换**。
	- 比如说：浏览器请求一个 web 服务器的界面，浏览器会把请求的数据传送到 web 服务器中，而 web 服务器会将相应的数据传送到浏览器上，经过浏览器的渲染，就可以看到我们经常在浏览器看到的各种界面了。
- 什么是协议？
	- 协议可以理解成一种约定俗成的规范，比如说：招聘时签的合同，租房子时候的合同等都可以看出是一种协议；
	- 而到了互联网，网络协议就是网络中 (包括互联网) 传递、管理信息的一些规范。如同人与人之间相互交流是需要遵循一定的规矩一样，计算机之间的相互通信需要共同遵守一定的规则，这些规则就称为**网络协议**。  
- 总结： **HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范**。

### 2. HTTP 常见字段有哪些？

- **Host 字段**：客户端发送请求时，用来指定服务器的域名。
	- 例如 `Host: www.baidu.com`
- **Content-Length 字段**：服务器在返回数据时，会有 `Content-Length` 字段，表明本次回应的数据长度。
	- 例如 `Content-Length: 1000` 表示告诉浏览器，本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。
- **Connection 字段**：最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。
	- HTTP/1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 `Connection` 首部字段的值为 `Keep-Alive`，即 `Connection: Keep-Alive`；
	- 开启了 HTTP Keep-Alive 机制后， 连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或服务器端提出断开连接。
- **Content-Type 字段**：用于服务器回应时，告诉客户端，本次数据是什么格式。
	- 例如 `Content-Type: text/html; Charset=utf-8` 表示返回的是网页，编码为 utf-8；
	- 客户端请求的时候，使用 `Accept` 字段声明自己可以接受哪些数据格式。例如 `Accept: */*` 表示客户端可以接收任何格式的数据。
- **Content-Encoding 字段**：数据的压缩方法，表示服务器返回的数据使用了什么压缩格式。
	- 例如 `Content-Encoding: gzip` 表示服务器的数据采用 gzip 压缩方式，客户端需要按照此各种进行解压；
	- 客户端在请求时，用 `Accept-Encoding` 字段说明自己可以接受哪些压缩方法。例如 `Accept-Encoding: gzip, deflate`。

### GET 和 POST 有什么区别？

- **GET 的语义是从服务器获取指定的资源**，这个资源可以是静态的文本、页面、图片视频等。GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 ，而且浏览器会对 URL 的长度有限制（HTTP 协议本身对 URL 长度并没有做任何规定）；
- **POST 的语义是根据请求负荷（报文 body）对指定的资源做出处理**，具体的处理方式视资源类型而不同。POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。

GET 和 POST 是安全幂等的吗？

- 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。
- 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。
- **GET 方法就是安全且幂等的**，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，**可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如 nginx），而且在浏览器中 GET 请求可以保存为书签**。
- **POST** 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据就会创建多个资源，所以**不是幂等**的。所以，**浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签**。

GET 请求可以带 body 吗？
- RFC 规范并没有规定 GET 请求不能带 body 的。理论上，**任何请求都可以带 body 的**。只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body。
- 另外，URL 中的查询参数也不是 GET 所独有的，**POST 请求的 URL 中也可以有参数的**。

## HTTP 请求报文/响应报文
相关问题：
- HTTP 请求头，请求行，请求体分别存放的是什么？

## HTTP 状态码
相关问题：
- 响应状态码 12345 开头的含义？
- 502，504 区别，403，404 区别？
- 504 状态码代表什么、403、302？
- http 的 3xx 状态码？

状态码（status-code）都是 3 位数字的，分为 5 大类共 33 种，简单介绍如下。

（1）lxx 表示通知信息，如请求收到了或正在进行处理。  
（2）2xx 表示成功，如接受或知道了。  
（3）3xx 表示重定向，如要完成请求还必须采取进一步的行动。  
（4）4xx 表示客户端错误，如请求中有错误的语法或不能完成。  
（5）5xx 表示 Web 服务器的差错，如 Web 服务器失效无法完成请求。

HTTP/1.1　202　Accepted（接受）  
HTTP/1.1　400　Bad Request（错误的请求）  
HTTP/1.1　404　Not Found（找不到）

|**消息  <br>**|**描述**|
|---|---|
|100 Continue|服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。|
|101 Switching Protocols|服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。|

|**消息  <br>**|**描述**|
|---|---|
|200 OK|请求成功（其后是对 GET 和 POST 请求的应答文档。）|
|201 Created|请求被创建完成，同时新的资源被创建。|
|202 Accepted|供处理的请求已被接受，但是处理未完成。|
|203 Non-authoritative Information|文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。|
|204 No Content|没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而 Servlet 可以确定用户文档足够新，这个状态代码是很有用的。|
|205 Reset Content|没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。|
|206 Partial Content|客户发送了一个带有 Range 头的 GET 请求，服务器完成了它。|

|**消息  <br>**|**描述**|
|---|---|
|300 Multiple Choices|多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。|
|301 Moved Permanently|所请求的页面已经转移至新的 url。|
|302 Found|所请求的页面已经临时转移至新的 url。|
|303 See Other|所请求的页面可在别的 url 下被找到。|
|304 Not Modified|未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供 If-Modified-Since 头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。|
|305 Use Proxy|客户请求的文档应该通过 Location 头所指明的代理服务器提取。|
|306 _Unused_|此代码被用于前一版本。目前已不再使用，但是代码依然被保留。|
|307 Temporary Redirect|被请求的页面已经临时移至新的 url。|

| **消息  <br>** | **描述** |
| ---- | ---- |
| 400 Bad Request | 服务器未能理解请求。 |
| 401 Unauthorized | 被请求的页面需要用户名和密码。 |
| 402 Payment Required | 此代码尚无法使用。 |
| 403 Forbidden | 对被请求页面的访问被禁止。 |
| 404 Not Found | 服务器无法找到被请求的页面。 |
| 405 Method Not Allowed | 请求中指定的方法不被允许。 |
| 406 Not Acceptable | 服务器生成的响应无法被客户端所接受。 |
| 407 Proxy Authentication Required | 用户必须首先使用代理服务器进行验证，这样请求才会被处理。 |
| 408 Request Timeout | 请求超出了服务器的等待时间。 |
| 409 Conflict | 由于冲突，请求无法被完成。 |
| 410 Gone | 被请求的页面不可用。 |
| 411 Length Required | "Content-Length" 未被定义。如果无此内容，服务器不会接受请求。 |
| 412 Precondition Failed | 请求中的前提条件被服务器评估为失败。 |
| 413 Request Entity Too Large | 由于所请求的实体的太大，服务器不会接受请求。 |
| 414 Request-url Too Long | 由于 url 太长，服务器不会接受请求。当 post 请求被转换为带有很长的查询信息的 get 请求时，就会发生这种情况。 |
| 415 Unsupported Media Type | 由于媒介类型不被支持，服务器不会接受请求。 |
| 416 Requested Range Not Satisfiable | 服务器不能满足客户在请求中指定的 Range 头。 |
| 417 Expectation Failed | 执行失败。 |
| 423 | 锁定的错误。 |

|**消息  <br>**|**描述**|
|---|---|
|500 Internal Server Error|请求未完成。服务器遇到不可预知的情况。|
|501 Not Implemented|请求未完成。服务器不支持所请求的功能。|
|502 Bad Gateway|请求未完成。服务器从上游服务器收到一个无效的响应。|
|503 Service Unavailable|请求未完成。服务器临时过载或宕机。|
|504 Gateway Timeout|网关超时。|
|505 HTTP Version Not Supported|服务器不支持请求中指明的 HTTP 协议版本。|

## HTTP 如何保持持久连接

HTTP 如何保证持久连接，为什么 1.0 不可以？

## HTTPS
相关问题：
- http 和 https 分别描述一下过程  
- HTTPS 证书有几类？单向还是多向？  
- https tls 数字证书，公私钥
- tls 握手详细问
- HTTP 与 HTTPS
- HTTPS 加密方式
- 对称加密、非对称加密
- HTTPS RSA 握手过程

## HTTP 不同版本对比
相关问题：
- HTTP1 和 HTTP2 的主要区别
- http 3.0

### HTTP/1.1 特性

HTTP 最突出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」。

- 1. **简单**：HTTP 基本的报文格式就是 `header + body`，头部信息也是 `key-value` 简单文本的形式，**易于理解**，降低了学习和使用的门槛。
- 2. **灵活和易于扩展**：HTTP 协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员**自定义和扩充**。同时 HTTP 由于是工作在应用层（ `OSI` 第七层），则它**下层可以随意变化**，比如：
	- HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层；
	- HTTP/1.1 和 HTTP/2.0 传输协议使用的是 TCP 协议，而到了 HTTP/3.0 传输协议改用了 UDP 协议。
- 3. **应用广泛和跨平台**：互联网发展至今，HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应用遍地开花，同时天然具有**跨平台**的优越性。

### HTTP/1.1 缺点

HTTP 协议里有优缺点一体的**双刃剑**，分别是「无状态、明文传输」，同时还有一大缺点「不安全」。
- 1. **无状态**：无状态意味着服务器不会去记录 HTTP 的状态，这样不需要额外的开销会记录状态信息，可以减轻服务器的负担。但是对于一些和身份认证相关的操作会比较麻烦，比如登陆、添加购物车、下单等等每次都需要请求用户的身份。解决方法：Cookie
- 2. **明文传输**：明文传输便于阅读，抓包之后可以直接查看，便于调试。但是 HTTP 的信息就暴露了，信息任意被窃取。
- 3. **不安全**：
	- 使用明文传输（不加密），内容任意被窃听；
	- 不验证通信方的身份，有可能遭遇伪装；
	- 无法证明报文的完整性，所以有可能已遭篡改；

安全问题可以通过 HTTPS 进行解决。

### HTTP/1.1 性能

HTTP 协议是基于 **TCP/IP**，并且使用了「**请求 - 应答**」的通信模式，所以性能的关键就在这**两点**里。

1. **长连接**：HTTP/1.0 的时候采用的是短连接，即每次发送一个请求就需要建立一次 TCP 连接（三次握手），而且是串行请求，做了 TCP 的连接和断开，增加了开销；HTTP/1.1 默认采用的是长连接，减少了 TCP 连接和断开的开销，可以复用 TCP 连接，减轻服务器的开销；
2. **管道网络传输**：HTTP/1.1 采用长连接使得可以通过管道传输。即在同一个 TCP 连接当中，客户端可以发起多个请求，第一个请求发送出去，不必等待，就可以继续发送第二个请求，**减少整体响应时间**；
3. **队头阻塞**：客户端可以发起多个请求，但是对于服务器来说，**必须按照接收请求的顺序发送对这些管道化请求的响应**。所以**HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞**。响应的队头阻塞即：当顺序发送的请求序列当中的一个请求阻塞的时候（比如处理时间较慢），后续的请求也会一直导致阻塞，客户端就一直接收不到数据。

### HTTP 和 HTTPS 有哪些区别？

- HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
- HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
- 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

### HTTPS 解决了哪些问题？

HTTP 是明文传输，有以下的风险：
- **窃听风险**，比如通信链路上可以获取通信内容，用户号容易没。
- **篡改风险**，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。
- **冒充风险**，比如冒充淘宝网站，用户钱容易没。

HTTPS 在 HTTP 和 TCP 层加入了 SSL/TSL 协议：
- **信息加密**：交互信息无法被窃取；
- **校验机制**：无法篡改通信内容，篡改了就不能正常显示；
- **身份证书**：证明淘宝是真的淘宝网；

HTTPS 是如何解决上面的风险的？

- **混合加密**的方式实现信息的**机密性**，解决了窃听的风险。
- **摘要算法**的方式来实现**完整性**，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。
- 将服务器公钥放入到**数字证书**中，解决了冒充的风险。

#### 1. 混合加密

HTTPS 采用的是**对称加密**和**非对称加密**结合的「混合加密」方式：
- 在通信建立前采用**非对称加密**的方式交换「会话秘钥」，后续就不再使用非对称加密。
- 在通信过程中全部使用**对称加密**的「会话秘钥」的方式加密明文数据。

采用「混合加密」的方式的原因：
- **对称加密**只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。
- **非对称加密**使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。

#### 2. 摘要算法 + 数字签名

为了保证传输的内容不被篡改，需要对内容计算得到一个「指纹」，同内容一并发送给对方。对方收到之后也是对内容进行计算「指纹」，然后做对比看是否相同，不相同则说明被篡改了。

计算机里会**用摘要算法（哈希函数）来计算出内容的哈希值**，也就是内容的「指纹」，这个**哈希值是唯一的，且无法通过哈希值推导出内容**。

通过哈希算法可以确保内容不会被篡改，**但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明**。

为了避免中间人篡改内容 + 哈希值，引入**非对称加密算法**来解决，有两个密钥：
- 公钥：可以公共给所有人；
- 私钥：必须有本人管理，不可泄露；

这两个密钥可以双向加密和解密，流程不同目的不同：
- **公钥加密，私钥解密**。这个目的是为了**保证内容传输的安全**，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；
- **私钥加密，公钥解密**。这个目的是为了**保证消息不会被冒充**，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。

一般不会用非对称加密来加密实际的传输内容，因为非对称加密的计算比较耗费性能的。所以非对称加密主要用来**通过「私钥加密，公钥解密」的方式，来确认消息的身份**，即**数字签名算法**，就是用的是这种方式，不过私钥加密内容不是内容本身，而是**对内容的哈希值加密**。

私钥是由服务端保管，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。

![](pics/Pasted%20image%2020231229112033.png)

#### 3. 数字证书

前面我们知道：
- 可以通过哈希算法来保证消息的完整性；
- 可以通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）；

但是这还不够，因为**公钥也可以是伪造的**。在计算机当中，有一个权威的机构即 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。

![](pics/Pasted%20image%2020231229112248.png)

### HTTPS 是如何建立连接的？

SSL/TSL 协议主要流程如下：
- 客户端向服务器索要并验证服务器的公钥。
- 双方协商生产「会话秘钥」。
- 双方采用「会话秘钥」进行加密通信。

前两个阶段是 SSL/TSL 建立过程，即 TSL 握手阶段，TLS 的「握手阶段」涉及**四次**通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，这里介绍 RSA 算法：

- 1）**ClientHello**：客户端向服务器发送加密通信请求，客户端发送 TSL 版本号、客户端生成的随机数、以及客户端支持的密码套件（如 RSA 算法）；
- 2）**ServerHello**：服务器收到客户端请求后，进行响应，内容如下：
	- 确认 TSL 版本号，不支持的话直接关闭加密通信；
	- 服务器生成随机数，用作后面生成会话密钥；
	- 确认密码套件，如 RSA 算法；
	- 服务器的数字证书；
- 3）**客户端回应**：客户端收到服务器响应后，通过浏览器的 CA 证书，来确认服务器的数字证书的真实性。如果证书没有问题，会取出服务器的公钥，使用它加密报文，向服务器发送以下内容：
	- 一个随机数，会被服务器公钥加密；
	- 加密通信算法改变通知，后续将使用会话密钥加密通信；
	- 客户端通知握手结束，同时将所有的内容的数据做个摘要，用来服务器进行校验。
	- **客户端和服务器都有了 3 个随机数之后会利用协商的加密算法（如 RSA）生成会话密钥。**
- 4）**服务器最后回应**：服务器收到第三个随机数的时候，会生成会话密钥，然后向客户端通知：
	- 加密通信算法改变通知，后续将用会话密钥加密通信；
	- 服务器握手结束通知，表示服务器握手阶段已经结束，同时将所有的内容数据做个摘要，供客户端进行校验。

![](pics/Pasted%20image%2020240101103832.png)

### HTTP2.0 优缺点

**HTTP1.1 的性能问题**：

随着网站的变化，消息大小在增加，页面的资源样式变多了，内容的形式也各种各样，实时性要求也在增加。这就导致 HTTP1.1 的高延迟，主要是以下几个原因：
- 1）**延迟难以下降**，虽然现在网络的「带宽」相比以前变多了，但是延迟降到一定幅度后，就很难再下降了，说白了就是到达了延迟的下限；
- 2）**并发连接有限**：谷歌浏览器最大并发连接数是 6 个，而且每一个连接都要经过 TCP 和 TLS 握手耗时，以及 TCP 慢启动过程给流量带来的影响；
- 3）**队头阻塞问题**：同一连接只能在完成一个 HTTP 事务（请求和响应）后，才能处理下一个事务；
- 4）**HTTP 头部巨大且重复**：由于 HTTP 协议是无状态的，每一个请求都得携带 HTTP 头部，特别是对于有携带 Cookie 的头部，而 Cookie 的大小通常很大；
- 5）**不支持服务器推送消息**：因此当客户端需要获取通知时，只能通过定时器不断地拉取消息，这无疑浪费大量了带宽和服务器资源。

**HTTP2.0 改进的地方**：

- 兼容 HTTP1.1，没有在 URI 当中引入新的协议名，仍然用「http://」表示明文协议，用「https://」表示加密协议，这样浏览器和服务器背后升级即可，用户意识不到；
- 只在应用层进行改变，仍是基于 TCP 协议，应用层保持向上兼容，HTTP 分解成了「语义」和「语法」两个部分，「语义」层不做改动，与 HTTP/1.1 完全一致，比如请求方法、状态码、头字段等规则保留不变。但是，HTTP/2 在「语法」层面做了很多改造，基本改变了 HTTP 报文的传输格式。主要改变如下：
	- 1）**头部压缩**：如果同时发送多个请求，头部是一样的，协议会对这部分进行压缩，消除重复的部分，采用的是 HPACK 算法，即服务器和客户端同时维护一张头信息表，所有字段都存入这张表，生成一个索引号，这样就不需要再发送字段，只需要发送索引号；
	- 2）**二进制格式**：不再像 HTTP1.0 采用纯文本形式的报文，全面采用了**二进制格式**，头信息和数据体都是二进制，并统称为帧（frame）：**头信息帧（Headers Frame）和数据帧（Data Frame）**；
	- 3）**并发传输**：针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP/2 可以并行交错地发送请求和响应。
	- 4）**服务器推送**：服务器可以主动向客户端发送消息，双方都可以建立 Stream ID，客户端建立的 Stream ID 必须为奇数，服务器必须为偶数。
		- 比如在 HTTP/2 中，客户端在访问 HTML 时，服务器可以直接主动推送 CSS 文件，减少了消息传递的次数。

**HTTP2.0 的缺点：**

1. **队头阻塞**：HTTP2.0 多个请求跑在一个 TCP 连接当中，如果 TCP 丢包了，整个 TCP 都需要等待，这就会导致阻塞该 TCP 连接当中所有的请求。因为 TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且有序的，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据，从 HTTP 视角看，就是请求被阻塞了。
2. **TCP 和 TSL 握手时延迟**：发起 HTTP 请求时，需要经过 TCP 三次握手和 TLS 四次握手（TLS 1.2）的过程，因此共需要 3 个 RTT 的时延才能发出请求数据。另外刚建立连接的 TCP 会有个慢启动的过程，会对 TCP 连接产生减速的影响。
3. **网络迁移需要重新连接**：一个 TCP 连接是由四元组（源 IP 地址，源端口，目标 IP 地址，目标端口）确定的，这意味着如果 IP 地址或者端口变动了，就会导致需要 TCP 与 TLS 重新握手，这不利于移动设备切换网络的场景，比如 4G 网络环境切换成 WiFi。

### HTTP3.0 优势

HTTP/3 就将传输层从 TCP 替换成了 UDP，并在 UDP 协议上开发了 QUIC 协议，来保证数据的可靠传输。

QUIC 协议的特点：
- **无队头阻塞**，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，也不会有底层协议限制，某个流发生丢包了，只会影响该流，其他流不受影响；
- **建立连接速度快**，因为 QUIC 内部包含 TLS 1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与 TLS 密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。
- **连接迁移**，QUIC 协议没有用四元组的方式来“绑定”连接，而是通过「连接 ID 」来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本；

另外 HTTP/3 的 QPACK 通过两个特殊的单向流来同步双方的动态表，解决了 HTTP/2 的 HPACK 队头阻塞问题。
## DNS 相关
相关问题：
1. DNS 的机理
2. DNS 用的是 TCP 还是 UDP，为什么？

### 1. DNS 是什么？

**官方解释**：DNS（Domain Name System，域名系统），因特网上作为**域名和 IP 地址相互映射**的一个**分布式数据库**，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。

通过主机名，最终得到该主机名对应的 IP 地址的过程叫做域名解析（或主机名解析）。

**通俗的讲**，我们更习惯于记住一个网站的名字，比如 www.baidu.com ,而不是记住它的 ip 地址，比如：167.23.10.2。

### 2. DNS 的工作原理？

将主机域名转换为 ip 地址，属于**应用层协议**，使用 **UDP** 传输。（DNS 应用层协议，以前有个考官问过）

1. **用户输入域名：** 用户在浏览器中输入一个域名，比如 www.example.com。
2. **本地缓存查询：** 操作系统首先检查本地 DNS 缓存，看是否已经解析过这个域名。如果有缓存记录，且未过期，就直接返回对应的 IP 地址。
3. **递归查询：** 如果本地缓存没有相应的记录，操作系统将查询发送给本地域名服务器（通常由 ISP 提供）。这个服务器可能会有缓存，如果有，它会返回缓存中的 IP 地址。否则，它将继续向更高级别的 DNS 服务器发出递归查询。
4. **根域名服务器：** 如果本地域名服务器没有相应的缓存记录，它将向根域名服务器发送查询。根域名服务器负责管理顶级域名服务器的 IP 地址。
5. **顶级域名服务器：** 根域名服务器返回一个指向顶级域名服务器的 IP 地址，例如 .com、.net 等。本地域名服务器再次发送查询到顶级域名服务器。
6. **权威域名服务器：** 顶级域名服务器返回一个指向目标域名的权威域名服务器的 IP 地址。本地域名服务器最终将查询发送到这个权威域名服务器。
7. **解析域名：** 权威域名服务器返回最终的目标域名对应的 IP 地址给本地域名服务器。
8. **返回给客户端：** 本地域名服务器将 IP 地址返回给用户的计算机，同时将解析结果缓存在本地，以便将来的查询加速。
9. **访问目标服务器：** 现在，用户的计算机拥有了目标域名的 IP 地址，它可以通过这个 IP 地址访问目标服务器，从而打开相应的网页或执行其他网络操作。

### 3. 为什么域名解析用 UDP 协议？

因为 UDP 快啊！UDP 的 DNS 协议只要一个请求、一个应答就好了。

而使用基于 TCP 的 DNS 协议要三次握手、发送数据以及应答、四次挥手，但是 UDP 协议传输内容不能超过 512 字节。

不过客户端向 DNS 服务器查询域名，一般返回的内容都不超过 512 字节，用 UDP 传输即可。

## 浏览器输入 URL 这中间发生了什么
相关问题：  
浏览器输入网址到呈现网页流程  
浏览器输入网址，直到打开网页的过程。（太典了）  
浏览器输入网址发生什么（从 dhcp，到 dns 解析，到 http，到 tcp，到 arp，到 nat、到局域网，因特网，我很详细地说了）  
发起一个请求域名，这中间发送什么？  

#TODO

## 讲一下一个数据包从网卡收包，到应用层的处理过程？

这个问题看似和上面那个很像，但实际上更加偏向操作系统，还是有很大区别的

参考博客：[不为人知的网络编程(十)：深入操作系统，从内核理解网络包的接收过程(Linux篇)](http://www.52im.net/thread-3247-1-1.html)

![](pics/Pasted%20image%2020231214092839.png)

大概过程如下：
1) 网络上收到数据包的时候，Linux 的网络驱动会开始工作，将网卡上收到的数据帧写到内存里。（这里不给自己挖坑，就不用提是以 DMA 的方式）
2) 然后驱动会发送一个硬中断通知 CPU 有数据到达。
3) CPU 收到中断请求的时候，会去调用网络驱动注册的中断处理函数进行处理。
4) 中断处理函数不做过多的处理，发送一个软中断请求，然后释放 CPU。
5) ksoftirqd （内核线程，专门处理软中断）检测到有软中断请求到达，调用 poll 开始轮询收包，收到后交由各级协议栈处理。
6) 协议栈开始处理网络帧，处理完的数据会被放到用户 socket 的接收队列中。
7) 最后再唤醒用户进程开始处理数据。

## Session、cookie 和 token

由于 HTTP 是一种无状态协议,服务器没有办法单单从网络连接上面知道访问者的身份,为了解决这个问题,就诞生了 Cookie

Cookie 实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用 response 向客户端浏览器颁发一个 Cookie

客户端浏览器会把 Cookie 保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该 Cookie 一同提交给服务器。服务器检查该 Cookie，以此来辨认用户状态。服务器还可以根据需要修改 Cookie 的内容。

实际就是颁发一个通行证，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是 Cookie 的工作原理

cookie 可以让服务端程序跟踪每个客户端的访问，但是每次客户端的访问都必须传回这些 Cookie，如果 Cookie 很多，这无形地增加了客户端与服务端的数据传输量，

而 Session 的出现正是为了解决这个问题。同一个客户端每次和服务端交互时，不需要每次都传回所有的 Cookie 值，而是只要传回一个 ID，这个 ID 是客户端第一次访问服务器的时候生成的， 而且每个客户端是唯一的。这样每个客户端就有了一个唯一的 ID，客户端只要传回这个 ID 就行了，这个 ID 通常是 NANE 为 JSESIONID 的一个 Cookie。

**区别**：

1、数据存放位置不同：cookie 数据存放在客户的浏览器上，session 数据放在服务器上。

2、安全程度不同：cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗,考虑到安全应当使用 session。

3、性能使用程度不同：session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用 cookie。

4、数据存储大小不同：单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie，而 session 则存储与服务端，浏览器对其没有限制。

5、会话机制不同 session 会话机制：session 会话机制是一种服务器端机制，它使用类似于哈希表（可能还有哈希表）的结构来保存信息。

cookies 会话机制：cookie 是服务器存储在本地计算机上的小块文本，并随每个请求发送到同一服务器。 Web 服务器使用 HTTP 标头将 cookie 发送到客户端。在客户端终端，浏览器解析 cookie 并将其保存为本地文件，该文件自动将来自同一服务器的任何请求绑定到这些 cookie。
