## 1 Table Indexes

在数据库系统中，有各种各样的数据结构，它们可以用在内部元数据、核心数据存储、临时数据结构或表索引等地方。对于表索引，可能会涉及到范围查询的扫面过程中。

表索引（table index）是表一部分列的副本，它们经过组织和（或）排序，以便在后续想使用这部分属性的时候可以高效的访问。DBMS 可以直接通过表索引来快速的查找元祖，而不是执行顺序扫描。但是，DBMS 需要确保表和索引的内容始终在逻辑上保持同步。

数据库索引的数量需要权衡，索引可以加快查询速度，但是维护索引本身也需要存储空间。DBMS 需要确定查询的时候使用最合适的索引。

## 2 B+Tree

B-Tree 是一种特殊的数据结构，一般用这个术语来泛指这一类数据结构，这里的 B 指的是 Balanced，B-Tree 的所有成员都是 Balanced 的，有以下几个成员：  
- B-Tree (1971)
- B+Tree (1973)
- B\*Tree (1977?)
- $B^{link}$-Tree (1981)  
（注：B-Tree 指的就是 B 树，可能也会有人说成 B- 树，但是这个不能读成 B 减树）

B+ 树是一种自平衡树数据结构，它保持数据有序，并允许在 O(log(n)) 时间复杂度内进行搜索、顺序访问、插入和删除操作。它经过优化后，适用于读写大块数据的磁盘导向型 DBMS。

原始 B- 树和 B+ 树之间的主要区别在于，B- 树在所有节点中存储键和值，而 B+ 树仅在叶节点中存储值。现代 B+ 树实现结合了其他 B- 树变种的特点，比如 $B^{link}$-Tree 中使用的兄弟指针。

通常来说，B+ 树是一种 M 路搜索树（其中 M 表示一个节点可以拥有的最大子节点数），具有以下属性：
- 它是完全平衡的（即每个叶节点位于相同的深度）。
- 除了根之外的每个内部节点至少半满（$M/2 − 1 \leq 键的数量 \leq M − 1$）。
- 每个具有 k 个键的内部节点有 k+1 个非空子节点。

### B+ Tree Nodes

B+ 树中的每个节点都包含一个键/值对数组。这些键值对的键基于索引的属性，比如创建一个学生 ID 的索引，键就是表中的学生 ID。根据节点是内部节点还是叶节点，值会有所不同：
- 内部节点中值是指向其他节点的指针。
- 叶子节点的值可能有两种：
	- 记录 ID（record IDs）： 是指向元组位置的指针。
	- 元祖数据（tuple data）：在每个节点中直接存储元组的内容。
		- 但是这种方法对次要索引（Secondary indexes）不太适用，次要索引的目的是提供对主索引（通常是主键）的引用，以便在检索主索引中的记录时能够快速定位它们的位置。因此，次要索引的值通常是记录 ID 或指向主索引中记录的指针。
- B+ 树的叶子节点还需要存储相邻节点的指针，这样在范围查询的时候，可以快速定位一个区间的所有叶子节点。

![](pics/Pasted%20image%2020230905194455.png)

B+ 树的每个节点上的数组都是按照键排序的。内部节点上的键可以看成是一个路标。它们指导树的遍历，但是这并不意味着键一定要在叶子节点上（因此值也可能不存在）。即在内部节点上可能有一个键（作为路标），但在叶节点上找不到这个键。

### Insertion

要将新键值对插入 B+ 树中，必须遍历树中的内部节点来找到需要插入的叶子节点的位置，插入算法大概如下：
1. 找到正确的叶节点 L。
2. 按排序顺序将新的键值对添加到 L 中：  
	- 如果 L 有足够的空间，操作完成。  
	- 否则将 L 分割成两个节点 L 和 L2。然后将 L 中的键值对均匀的重新分配到 L 和 L2 两个节点上，并在 L 的父节点中插入指向 L2 的索引条目。
3. 如果要拆分内部节点，需要均匀重新分配条目，同时将 middle key 向上推送。（这里的 middle key 指的是新分裂出来的节点的索引，一般是第一个 key）

### Deletion

如果删除操作导致节点不满足半满状态，需要合并节点来重新平衡树。删除算法如下：
1. 找到正确的叶节点 L。
2. 删除条目：  
	- 如果 L 至少半满，操作完成。  
	- 否则，可以尝试重新分配，即从兄弟节点借用条目。
	- 如果重新分配失败，合并 L 和兄弟节点。
3. 如果发生了合并，必须删除父节点中指向 L 的条目。

### Selection Conditions

由于 B+ 树是按顺序排列的，查找具有快速遍历的特点，并且不需要整个键。如果查询提供搜索键的任何属性，DBMS 都可以使用 B+ 树索引。这与哈希索引不同，哈希索引需要搜索键中的所有属性。

例如要在 B+ 树上执行前缀搜索，可以查看键的第一个属性，沿着路径向下并在叶子节点上执行顺序扫描，这样就可以找到所有需要的键。

![](pics/Pasted%20image%2020230905202703.png)

### Non-Unique Indexes

与哈希表类似，B+ 树可以通过重复键（duplicate keys）或存储值列表（store value lists）来处理非唯一索引。
- 在重复键的方法中，使用相同的叶子节点布局，但重复的键存储多次。
- 在值列表的方法中，每个键只存储一次，并维护一个链表来存放这些值。

> 补充：非唯一索引允许在索引列中包含重复的值。这意味着多个表行可以具有相同的索引键值，因此非唯一索引不会强制要求数据的唯一性约束。
### Duplicate Keys

在 B+ 树中处理重复键（Duplicate Keys）有两种方法：  

第一种方法是将记录 ID 作为键的一部分。由于每个元组的记录 ID 是唯一的，这可以保证所有的键都是唯一识别的。  

![](pics/Pasted%20image%2020230905204029.png)

第二种方法是允许叶节点，将重复的键放到溢出节点（overflow nodes）上。虽然不存储冗余信息，但这种方法在维护和修改上更加复杂。

![](pics/Pasted%20image%2020230905204125.png)

### Clustered Indexes
  
表可以采用堆组织存储或索引组织存储方式，按照主键的顺序存储。由于一些 DBMS 始终使用聚集索引（Clustered Indexes），如果表没有显式定义主键，它们会自动创建一个隐藏的行 ID 作为主键，但其他一些 DBMS 则无法使用这种方法。

### Heap Clustering

元组在堆页面中根据聚集索引指定的顺序进行排序。如果使用聚集索引的属性来访问元组，DBMS 可以直接跳转到页面。
### Index Scan Page Sorting

由于直接从非聚集索引中检索元组效率低下，DBMS 可以首先确定所需的所有元组，然后根据它们的页面 ID 对它们进行排序。这可以提高检索效率。

![](pics/Pasted%20image%2020230905205012.png)

## 3 B+Tree Design Choices
### 3.1 Node Size

根据存储介质的不同，可以选择合适的节点大小，一般来说存储设备越慢，B+Tree 的最合适的节点大小越大。
- 例如，存储在硬盘驱动器上的节点通常大小约为兆字节（~1MB），这样可以查询的过程中可以减少读取磁盘的次数，减少磁盘 IO 开销；
- 而内存数据库使用的节点大小可能小至 512 字节，这样可以将整个页面放入 CPU 缓存中，从而减少数据的碎片。

节点大小还可以取决于工作负载的类型，因为节点查询（Leaf Node Scans）更喜欢尽可能小的页面，以减少加载的不必要的额外信息，而大型顺序扫描（Root-to-Leaf Traversals）可能更喜欢大页面，以减少从磁盘中获取页面的次数。

### 3.2 Merge Threshold

B+ 数在删除操作之后，对于不满足半满 (half full) 状态的节点，需要从兄弟节点借用或者合并节点。但是有的 DBMS 并不会立刻就合并节点，延缓合并操作可能会减少删除操作的次数。例如，急于合并节点可能导致频繁分裂和合并，即大量连续的删除和插入操作。

最好让小节点存在（没到半满），然后定期的重新构建整个树。也可以允许批量合并，多个合并操作可以一次完成，从而减少了需要获取树上写锁的时间。

### 3.3 Variable Length Keys

目前，只讨论了具有固定长度键的 B+ 树。然而，我们可能还希望支持可变长度的键，例如，大键的一小部分子集导致大量空间浪费的情况。有几种处理这种情况的方法：

- Pointers：可以只存储指向键的指针，而不是直接存储键。
- Variable Length Nodes：也可以像通常一样存储键值，并允许节点的长度可变。但是由于处理可变长度节点需要处理较大的内存开销，这种方法基本上不被使用。
- Padding：可以将每个键的大小设置为最大键的大小，并填充所有较短的键，而不是改变键的大小，这种情况也是很浪费内存的。
- Key Map/Indirection：用一个指向字典中键值对的索引来替代键。这种方法可以显著节省空间，并且可能快捷地执行点查询（因为索引指向的键值对与叶节点指向的键值对完全相同）。由于字典索引值的大小很小，足够的空间可以用来存放每个键的前缀，从而使一些索引搜索和叶节点扫描不必追踪指针（如果前缀与搜索键不同的话）。

下面是 Key Map/Indirection 的一个示例，字典存放了一个键的一小部分前缀，同时存放了一个指针指向键值对：

![](pics/Pasted%20image%2020230906143420.png)

### 3.4 Intra-Node Search

一旦找到一个节点，需要在节点内搜索，要么从内部节点找到下一个节点，要么在叶节点中找到我们的键值。有以下几种搜索方式：

1. Linear 线性查找

最简单的解决方案是扫描节点中的每个键，直到找到我们的键：
- 这样搜索不需要对键进行排序，插入和删除速度更快。
- 但是这样比较低效，每次搜索的复杂度为 O(n)。
- 可以使用 SIMD（或等效）指令进行矢量化。（这个是什么？打个问号）

2. Binary 二分查找

更加有效的方法是进行二分查找，这种搜索复杂度为 O(logn)，但是插入的时间复杂度变高，因为要维护节点中的键是有序的，才可以进行二分查找。

3. Interpolation

在某些情况下可以利用插值来找到密钥。此方法利用存储的有关节点的任何元数据（例如最大元素、最小元素、平均值等），并使用它来生成键的大致位置。 例如，如果在节点中查找 8 并且 10 是最大键，10 − (n + 1) 是最小键（其中 n 是每个节点中键的数量），那么我们知道开始从最大键向下搜索 2 个槽，因为在这种情况下，距离最大键 1 个槽的键必须是 9。 尽管这是我们给出的最快的方法，但由于它对具有某些属性（如整数）和复杂性的密钥的适用性有限，因此该方法仅在学术数据库中出现。

![](pics/Pasted%20image%2020230906144359.png)

## 4 Optimizations
### 4.1 Pointer Swizzling

B+ 树的节点都存放在缓冲池中，每次加载一个新的页面都需要从缓冲池中获取。如果页面固定在缓存池中的话，可以存储指向内存的原始指针，而不是 page id。这样可以避免从页表获取地址。

需要注意的是，必须跟着哪些存放的是原始指针的，当它指向的页面被 unpin 或者替换掉的时候，需要将其还原成 page id。

![](pics/Pasted%20image%2020230906145427.png)

### 4.2 Bulk Insert

B+ 树构建的时候，一般是不断的插入键，这样会导致分裂。更加快的方式是将键先排序，然后使用每个叶节点的第一个键从下往上的构建索引。

Keys: 3, 7, 9, 13, 6, 1  
Sorted Keys: 1, 3, 6, 7, 9, 13

![](pics/Pasted%20image%2020230906145809.png)

### 4.3 Prefix Compression

大多数时候，同一个节点上面的键，它们的前缀都会有部分重叠（因为相似的键最终会在排序的 B+Tree 中紧邻彼此）。 可以将前缀在节点的开头存储一次，然后只在每个槽中存储每个键的唯一部分。

![](pics/Pasted%20image%2020230906150030.png)

### 4.4 Deduplication

在允许非唯一键的索引（Non-unique indexes）的情况下，叶子节点最终可能会有多个相同的键。 一种优化可能是只写入一次键，然后在其后面写入所有关联的值。

![](pics/Pasted%20image%2020230906150320.png)

### 4.5 Suffix Truncation

大多数情况下，内部节点中的键条目仅用作路标，而并不是实际的键值（因为即使索引中存在键，仍然需要搜索到叶子节点以确保它没有被删除）。可以存储能够正确区分索引的最小前缀即可，而不需要存储完整的键。

![](pics/Pasted%20image%2020230906150745.png)