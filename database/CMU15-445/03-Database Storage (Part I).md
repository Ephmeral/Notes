## 1 Storage

我们将重点关注“面向磁盘”的 DBMS 架构，该架构假设数据库的主要存储位置位于非易失性磁盘上。

![](pics/Pasted%20image%2020230828184020.png)

在存储层次结构的顶部，您拥有最靠近 CPU 的设备。 这是最快的存储，但也是最小且最昂贵的。 距离 CPU 越远，存储设备就越大，但速度越慢。 这些设备的每 GB 价格也变得更便宜。

**易失性设备（Volatile Devices）**：  
- 易失性意味着如果关闭机器电源，数据就会丢失。  
- 易失性存储支持通过字节寻址位置进行快速随机访问。 这意味着程序可以跳转到任何字节地址并获取那里的数据。  
- 就我们的目的而言，我们始终将此存储类别称为“内存（Memory）”。

**非易失性设备（Non-Volatile Devices）**：  
- 非易失性意味着存储设备不需要连续供电即可保留其所存储的位。  
- 它也是块/页可寻址的。 这意味着，为了读取特定偏移处的值，程序首先必须将 4 KB 页加载到保存程序想要读取的值的内存中。  
- 传统上，非易失性存储更适合顺序访问（同时读取多个连续的数据块）。  
- 我们将其称为“磁盘（Disk）”。 我们不会对固态存储 (SSD) 和旋转硬盘 (HDD) 进行（主要）区分。

还有一类相对较新的存储设备越来越流行，称为持久内存（persistent memory）。 这些设备被设计为两全其美：几乎与 DRAM 一样快，并且具有磁盘持久性。 我们不会在本课程中介绍这些设备，它们目前还没有在生产中广泛使用。最著名的例子可能是 Optane； 不幸的是，英特尔将从 2022 年夏季开始逐步减少生产。请注意，您可能会看到较早的将持久内存称为“非易失性内存（non-volatile memory）”。

您可能会看到对 NVMe SSD 的，其中 NVMe 代表非易失性内存。 这些 NVMe SSD 与持久内存模块不是同一硬件。 相反，它们是典型的 NAND 闪存驱动器，通过改进的硬件接口进行连接。 这种改进的硬件接口可实现更快的传输，从而利用 NAND 闪存性能的改进。

由于我们的 DBMS 架构假设数据库存储在磁盘上，因此 DBMS 的组件负责确定如何在非易失性磁盘和易失性内存之间移动数据，因为系统无法直接操作磁盘上的数据。

![](pics/Pasted%20image%2020230828190224.png)

如果从 L1 缓存引用读取数据需要 1 秒，那么从 SSD 读取数据需要 4.4 小时，从 HDD 读取数据需则要 3.3 周。

非易失性存储上的随机访问几乎总是比顺序访问慢得多。DBMS 希望最大化顺序访问：  
- 算法尝试减少随机页的写入次数，以便数据存储在连续的块中；  
- 同时分配多个页称为 extent；

## 2 Disk-Oriented DBMS Overview

![](pics/Pasted%20image%2020230828191042.png)

- 数据库全部在磁盘上，数据库文件中的数据被组织成页，第一页是目录页；
- 为了对数据进行操作，DBMS 需要将数据放入内存中。 它通过一个缓冲池（Buffer Pool）在磁盘和内存之间的数据进行来回移动；
- DBMS 还有一个执行查询的执行引擎。 执行引擎将向缓冲池请求特定页面，缓冲池将负责将该页面放入内存中，并为执行引擎提供指向内存中该页面的指针。 缓冲池管理器将保证当执行引擎操作这些页面的时候，页面仍然存在内存中；

## 3 DBMS vs. OS

DBMS 的高级设计目标是支持超出可用内存量的数据库。由于读/写磁盘的成本很高，因此必须仔细管理磁盘的使用。 我们不希望从磁盘获取某些内容时出现大的停顿，从而减慢其他的操作。我们希望 DBMS 在等待从磁盘获取数据时，仍然能够处理其他查询。  

这种高级设计目标就像虚拟内存一样，其中有很大的地址空间，供操作系统从磁盘中调入页面。

实现这种虚拟内存的一种方法是使用 mmap 将文件的内容映射到进程的地址空间中，这使得操作系统负责在磁盘和内存之间来回移动页面。 不幸的是，如果 mmap 遇到页面错误，该进程将被阻塞。

![](pics/Pasted%20image%2020230828193920.png)

如果我们允许多个线程访问 mmap 文件，来隐藏发生页面错误导致的停顿会怎么样？
- 对于只读访问，性能足够好；
- 但是对于多线程写入，会变得很复杂；

内存映射 I/O 问题：
- 问题 1：事务安全性 - 操作系统随时可以刷新脏页面。
- 问题 2：I/O 中断 - 数据库管理系统不知道哪些页面在内存中。操作系统将在页错误时阻塞线程。
- 问题 3：错误处理 - 难以验证页面。任何访问都可能引发 DBMS 必须处理的 SIGBUS 错误。
- 问题 4：性能问题 - 操作系统数据结构争用。TLB shootdowns（转译后的页表清除）。

更详细内容可以看下 Andy 的论文：[Are You Sure You Want to Use MMAP in Your Database Management System? (cmu.edu)](https://db.cs.cmu.edu/papers/2022/cidr2022-p13-crotty.pdf)

可以通过以下方式使用操作系统：  
• madvise：告诉操作系统您何时计划阅读某些页面。  
• mlock：告诉操作系统不要将内存范围交换到磁盘。  
• msync：告诉操作系统将内存范围刷新到磁盘。

出于正确性和性能方面的原因，不建议在 DBMS 中使用 mmap。尽管系统将具有看起来像操作系统可以提供的功能，但让 DBMS 本身实现这些过程可以为其提供更好的控制和性能。
- 将脏页按照正确的顺序刷新到磁盘上；
- 根据具体情况预获取数据；
- 缓冲区替换策略；
- 线程/进程调度；

## 4 File Storage

大多数情况下，DBMS 将数据库作为文件存储在磁盘上。 有些 DBMS 可能使用文件层次结构，其他的可能使用单个文件（例如 SQLite）。  

操作系统对这些文件的内容一无所知。 只有 DBMS 知道如何解密其内容，因为它是以 DBMS 特定的格式编码的。  

DBMS 的存储管理器（storage manager）负责管理数据库的文件，它将文件表示为页面的集合。
- 它还跟踪哪些数据被读取或写入到页面中；
- 跟踪这些页面中还有多少可用空间；

## 5 Database Pages

DBMS 将数据库组织在一个或多个固定大小的数据块（称为页）中的文件中。
- 页面可以包含不同类型的数据（元组、索引等）；
- 大多数系统不会在页面内混合这些类型；
- 有些系统要求页面是独立的，这意味着读取每个页面所需的所有信息都在页面本身上；

每个页面都有一个唯一的标识符。 如果数据库是单个文件，则页面 id 可以只是文件偏移量。 大多数 DBMS 都有一个间接层，将页面 ID 映射到文件路径和偏移量。 系统的上层会要求特定的页码。 然后，存储管理器必须将该页号转换为文件和偏移量才能找到该页。

大多数 DBMS 使用固定大小的页面来避免支持可变大小的页面所需的工程开销。 例如，对于可变大小的页面，删除页面可能会在文件中产生一个洞，而 DBMS 无法轻松地用新页面填充该洞。

在数据库管理系统中有三个页面的概念：
1. 硬件页面（通常为 4 KB）；
2. 操作系统页面（4 KB）；
3. 数据库页面（512B-16 KB）；

存储设备保证硬件页面大小按照原子的方式写入。如果硬件页面为 4 KB，并且系统尝试将 4 KB 写入磁盘，则要么全部 4 KB 都将被写入，要么全部都不写入。 这意味着，如果我们的数据库页大于硬件页，DBMS 将必须采取额外措施来确保数据安全写出，因为当系统崩溃时，程序可能会在将数据库页写入磁盘时中途停止。

## 6 Database Heap

不同的 DBMS 以不同的方式管理磁盘上文件中的页面：
- 堆文件组织  
- 树形文件组织  
- 顺序/排序文件组织 (ISAM)  
- 散列文件组织  

堆文件（heap file）是无序的页面集合，其中元组以随机顺序存储：
- 创建/获取/写入/删除页面  
- 还必须支持迭代所有页面。

如果只有一个文件，查找页面是很容易的。但是多个文件的时候下，需要元数据来跟踪哪些页面存在于多个文件中，以及哪些页面具有空闲空间。

DBMS 维护特殊页来跟踪数据库文件中数据页的位置，必须确保目录页与数据页同步。该目录页还记录有关可用空间的元数据：  
- 每页的空闲槽数；
- 空闲/空页面列表；

![](pics/Pasted%20image%2020230828202847.png)

此外还可以通过页面链表来定位磁盘中的页面。链表的页头页面包含指向空闲页面列表和数据页面列表的指针。然而，如果 DBMS 正在查找特定页面，则必须在数据页面列表上进行顺序扫描，直到找到所需页面。  

![](pics/Pasted%20image%2020230828203201.jpg)

## 7 Page Layout

每个页面都包含一个 header，用于记录有关页面内容的元数据：  
• 页面大小。  
• 校验和。  
• DBMS 版本。  
• 交易可见性。  
• 自我封闭。 （某些系统，例如 Oracle）

在页面中记录数据有两种主要方法：
- (1) Tuple-oriented：记录数据本身
- (2) Log-structured：记录数据的操作日志

### Tuple-oriented
#### Strawman Idea

记录数据的一种简单的方法是跟踪 DBMS 在页面中存储了多少元组，然后在每次添加新元组时追加到末尾。 这种方法的缺点是：
- 一旦出现删除操作，每次插入就需要遍历一遍，寻找空位，否则就会出现空间浪费；
- 无法处理变长的数据记录（tuple）；

![](pics/Pasted%20image%2020230828205638.png)

#### Slotted Pages

这种方法是在 Header 的后面一个 slot 数组，slot 数组映射了 tuple（数据记录）在文件中的起始偏移量。header 会跟踪：
- 使用了多少个 slots；
- 最后已使用 slot 的起始位置偏移量。

![](pics/Pasted%20image%2020230828204935.png)

• 要添加一个 tuple 的时候，slot 数组将从开头增长到末尾，tuple 的数据将从末尾增长到开头。当 slot 数组和 tuple 数据相遇时，页面被认为是满的；
- 当删除一个 tuple 的时候，比如这里的 Tuple 3，此时将 slot 数组中的第三条记录删除，同时将 Tuple 4 和后面的数据往后移动，以填充 Tuple 3 的空洞，slot 数组也同样的往前移动；

### Log-structured

日志结构：将在下一讲中介绍。

## 8 Tuple Layout

tuple 本质上是字节序列。DBMS 的工作是将这些字节解释为属性类型和值。

**元祖头部（Tuple Header）**：包含 tuple 的元数据  
• DBMS 并发控制协议的可见性信息（即有关哪个事务创建/修改该元组的信息）；  
• NULL 值的位图；  
• 请注意，DBMS 不需要在此处存储有关数据库模式的元数据；

![](pics/Pasted%20image%2020230828212022.png)

**元祖数据（Tuple Data）**：tuple 中的实际数据  
• 属性通常按照您在创建表时指定的顺序存储；  
• 大多数 DBMS 不允许 tuple 超过页的大小；

![](pics/Pasted%20image%2020230828212031.png)

**唯一标识符（Unique Identifier）**：  
• 数据库中的每个元组都分配有一个唯一的标识符；  
• 最常见：page id + (offset or slot)；  
• 应用程序不能依赖这些 ID 来表示任何含义；

**非规范化元组数据（Denormalized Tuple Data**）：如果两个表相关，DBMS 可以预先 join 它们，因此这些表最终位于同一页面上。 这使得读取速度更快，因为 DBMS 只需加载一页而不是两个单独的页面。 然而，它使得更新成本更高，因为 DBMS 需要为每个元组提供更多空间。

![](pics/Pasted%20image%2020230828212803.png)  
![](pics/Pasted%20image%2020230828212656.png)  
![](pics/Pasted%20image%2020230828212706.png)

